Dịch sang tiếng Việt bài giảng sau:

```
Linux isn't just a thing to brag about to potential romantic Partners Linux skills and more broadly speaking the ability to use the command line the shell the terminal is going to be useful in any software engineering job and even any devops it or automation job and if you're working anywhere close to the internet understanding Linux is going to be something that's invaluable to your tool set so in this video I'm going to walk you through our entire intro to Linux course on boot. deev but up front
I want want to explain to you exactly what this course is and what it's not I'm calling it learn Linux just because that's what most people think of and Associate the terminal with when they think of Ls CD GP find they think of Linux but to be honest the name of the course is a bit of a misnomer it should probably really be called learn how to use shells and terminals in a Unix likee environment it's a unit system I know this so we'll be focused on on shells and terminals in this course and you can
use Linux or Mac which are both Unix like navigating the command line on those operating systems feels pretty similar if you are on Windows don't worry we're going to set you up with a WSL or Windows subsystem for Linux environment so that you can follow along in Ubuntu the chapters in this course are Terminals and shells file systems permissions programs input output and package managers the goal of this course is that when you're done you're going to feel very comfortable using the terminal
to do your daily work both on Linux or on Mac and if you're in a job where you work with remote servers for example remote web Linux servers you're going to feel really comfortable navigating around the file systems on that kind of a server that said this is not a course on the Linux kernel or on the operating system or on server Administration this course is really a prerequisite to those types of courses this Linux course is course number two on the backend developer road map on boot Dev for a reason and that's because all of the
shells and terminal skills you're going to pick up in this course are something that not only every backend developer should have but I really believe every developer in general should understand how to navigate the command line now by the way just so you know who's teaching you this thing I'm Lane I'm the creator of boot dodev which is an interactive platform for software engineering education I've been writing code for about 15 years now and professionally for about eight I've mostly specialized
in backend and data engineering but like most developers I've dabbled all across the stack now let's talk about how you're actually going to complete this course option one is to go grab a bag of popcorn sit back and watch as I do all the work for you you can pretend you're learning as I type everything out that's not a good option if you watch this entire course without pausing you've done it wrong so make sure that you're at a computer that you have access to a terminal and actually follow along as we
go through this entire course now the content of this course just like all courses on bootd is totally free I highly recommend going over to boot. making a free account and following along with all the text instructions as you watch this video now what makes this free content model work is that all of the interactivity on bootd after a certain point is paid so if you like all of the gamification features if you like the solution peaking the AI assistant the certificates all that stuff that is available with a paid membership but you
don't need the paid membership to take this course but if you do want to become a member I've got a coupon code for you you can use code boots for 25% off your first year if you choose an annual plan now enough with the Shilling let's talk about what happens if you get stuck during this course please don't ask for help in the YouTube comments I can't reasonably help you there head over to the boot dodev Discord totally free to join feel free to ask question questions in there now let's talk about shells
Terminals and Linux all right so I'm here on the learn Linux course learn shells and terminals course on boot. and let's jump into it so just to give you kind of a lay of the land I've got my terminal emulator here on the right this is ghosty and then I've got the lesson instructions on the leand side of the screen and this first lesson I'm going to kind of skip this first part because we already went over that that in the introduction to this video so let's just jump straight into the assignment all right so find an open
a terminal on your computer I have opened ghosty I'm on Mac OS if you're on Mac you could use ghosty you could use the built-in terminal if you're on Windows you can open the command prompt and if you're on Linux hopefully you know where your terminal is so we're just going to grab this paste it into our terminal and run it and Echo hello world it just prints back hello world to the console and then it says once we've done that just answer the question so hop over to the question what happened
when you press ENT the text hello world was printed to the terminal console pretty straightforward if you're coming from the world of pythons there a lot like print hello world or in go fm. print line hello world this is this is the terminal or the Shell's equivalent of print hello world the words terminal shell command line CLI and command prompt are often just thrown around haphazardly by programmers and even though the precise definitions very slightly we're usually talking about a program that lets you interact with your
machine through text if you're new to the command line you're already probably familiar with guies or graphical user interfaces and a GUI is just a fancy visual interface that lets you get stuff done on your computer think of a Windows desktop for example it has menus to sift through icons to click on and even complex window Management Systems a CLI or command line interface is a much simpler alternative instead of using complex visual buttons and menus you interact solely through text want to run a program don't click on an IC icon just
type the name of the program want to view a file don't open Microsoft Word just type a command now while goys do have a lower barrier to entry that is they're often self-explanatory to use they're also pretty limited a command line interface is more powerful because you're not limited to the buttons and widgets that are provided by application developers instead you get direct access to the lower levels of your system as a programmer it's non-negotiable you need to be comfortable on a command line all
right next Lon command line versus guy or graphical user interface so in all the other courses on bootd or I should say kind of the beginner courses you'll be coding mostly in your browser uh and when you want to run your code you'd be clicking a run button but typically as a real developer and that's not entirely true this is you know the skews toward my experience as a web developer but it's it's very often the case that you'll be running your programs from the command line rather than by clicking a
run button of course there are exceptions to this there are uh idees out there where you do click a run button and those developers aren't any less professional than those of us who use the command line but it is very good to become familiar with the command line because you will be using it for example when I'm writing python code I'm typically running my code by typing python main.
py into the terminal rather than clicking a run button in my editor that's just the way I like to write my code or I should say to set up my development environment so what is a CLI well it stands for command line interface but it's a text interface for interacting with applications and programs so if you're coming you know not from a developer background you're probably used to interacting with your computer through graphical user interfaces you're clicking around on different icons you navigate folder structures using something like Windows
Explorer or finder on Mac and you're using your mouse a lot uh you're using your mouse you're looking at images you're clicking on things that's what a graphical user interface is a command line interface is text only which I mean basically that means it's going to be harder to learn because you have to learn all of the different commands but once you know the commands it's actually a lot faster to use a command line interface typically because it is all text and so you can go as fast as you
can type um it also makes automating things a lot easier because it's a lot easier to write a program that works with text than a program that you know tries to spoof Mouse clicks and things like that so onto the assignment for this one says in your terminal run the following command who am I who am I I get Wags Lane that's again I'm on Mac that's the name of my logged in user account and when we're done we answer the question what happened when you ran the command uh my username was printed to the console all right the
next lesson is on installing Windows subsystem for Linux now I'm going to skip this section because I'm not on Windows if you're on Windows you will not be able to use just the default command prompt for the rest of the course you'll be using Linux running on your Windows machine with WSL so if you are on Windows and you need to set up WSL please come to this lesson it's lesson three in chapter 1 and all the instructions are here this is very battle tested we've had thousands of students install WSL and use it don't
worry it won't bork your Windows installation it's not a entirely separate like dual boot situation where you have to like partition your disc it's nothing crazy like that it's really genuinely pretty simple to set up that's why we recommend it so if you're on Windows and you need to get WSL set up set this up once you're done with this you will have a Linux terminal a Linux shell that you can use it'll be a it'll be bash and you'll be able to follow along with the rest of the course for
the rest of the course everything we do will work with bash and zsh as the two shelves on Linux and mac and there really won't be much customization that needs to happen both Linux and Mac are Unix like systems and all the stuff we're going to cover in here is similar enough that it will work so we'll go ahead and skip that one all right so what is a terminal now as developers sometimes we use all these terms interchangeably and what terms are they terminals shells command line interfaces you'll often hear developers use those
different words to just refer to the same thing which basically means I'm typing text into my terminal and so just just understand that we often mean the same thing and we kind of get sloppy with words but they do actually have different definitions so a terminal to get super pedantic actually doesn't really exist on your computer at all a terminal is a physical device like this this big old image here so way back in the day you had to have like a terminal you could basically think of it as like a monitor keyboard combo and it's what
allowed you to interact with software it's like a physical terminal these days we don't use those very often we use terminal emulators so that's what ghosty is it's a program on my computer that emulates a terminal it allows me to type text in and it renders text out back to me so to get very pedantic a terminal is just that it's a place where you can type in text in a place that can render the text back so let's answer the question a terminal or terminal emulator is a text-based operating system a set
of commands that can be used to control a computer a program that accepts text based commands and can render text on the screen or is a freshly baked Raspberry Pi it is a program that accepts text based commands and can render text on the screen okay so if that's what a terminal is then I mean I don't want to in I don't want to offend anyone who works on terminals because and to be clear they're not simple programs necessarily but when you compare it to the Shell the terminal can be thought of as kind of dumb like it
doesn't actually have to interpret commands all it has to do is accept text and render text so the shell is the program that actually provides the interactivity in the terminal it it waits for the prompt it processes The Prompt it interprets The Prompt it executes the prompt and then it gives you new prompt when it's done processing the old prompt the acronym for this is repple read evaluate print Loop so when we type a command like Echo hello world when I hit enter the very first thing the shell does because the terminal is
sending that command to the Shell the shell reads that Echo hello world it evaluates it what should I do with this prompt it prints a response in this case Hello World and then it loops and gives me a new prompt which is why I'm able to do it again so in your own shell run the following command let's go ahead and run this looks like it's adding up some numbers paste the output of that command into the text box all right let's hop over to the text box paste that in and this is really just to show another
example of a prompt that our shell can evaluate right so in this case we're saying expression 1 2 3 4 5 6 plus 7890 it actually does that addition shells like bash or in my case zsh they're sophisticated programming languages and they can do a lot of things so it's not just that they can Echo hello world back to you uh they can also do math so like we said in the last lesson these shells zsh and Bash they're reppel but they're also kind of fully-fledged programming languages they're built to be fairly simple
scripting languages so they're not always best for building larger web applications uh shout out Sarah and Bash stack making it possible although maybe not recommended but the point is you can do very sophisticated things uh in bash and zsh and just kind of shell scripting in general and so like most programming languages you can use and create variables in bash and zsh creating a variable is very simple so for example here I can create the variable name set it equal to my name Lane and if I want to use the variable this is where it
gets a little different from a language like python instead of just using using the variable name name again I actually have to prefix it with this dollar sign so anytime you set a variable you don't need the dollar sign but when you use it you do we can Echo that back out you can see it inter it interpolated the string Lane back into the name variable so for the assignment for the rest of this course you'll be a forensic developer hired by the fictional World Bank to investigate a security breach and like most Mega
corporations they don't know what they're doing uh but they're happy to overpay you to come in so they can say a third party for his reviewed their systems as it turns out you're not an expert yet we're going to learn in this course uh but you are happy to learn on someone else's dime so why don't we jump right into it anyhow you'll be using your terminal shell to Traverse files manipulate text run programs right this is all the stuff that we'll be learning throughout the course but we'll do it
we'll do it within the kind of story-based context of this World Bank Mega Corporation we're going to be a forensic developer looking around through files grepping through stuff finding stuff printing it out um and doing just kind of General analysis on text as a way way to kind of practically learn how to navigate a Unix like system and I don't I don't didn't really cover this in depth but like the course is called learn Linux and a lot of you will be on Linux but Mac from a text based perspective uh
like on the command line is very similar to Linux we call it it's Unix like and so all this stuff kind of just works out of the box server Administration is like a whole another can of worms like it's not like a Linux server and a Mac server cre equally and also to say local development isn't exactly the same either but the point is a local development and kind of navigating your shell and terminal on Mac is very similar to Linux whereas Windows is not that's why if you're on Windows we have
you use a Linux virtual machine specifically WSL okay so for the first part of the assignment set the following three variables in your shell so first we're going to set Bank name equal to World Bank founded equal to 1969 and the CEO is the famous Jeff Gates next we're going to write an execute a command that will print the following using Echo and the dynamical variables that we just set so we're going to Echo the string now we have a variable for World bank so I'm go dollar sign world or sorry dollar sign Bank
name Bank name uh was founded in um I think we go dollar sign founded interpolate that variable in and then buy dollar sign CEO run that see if it worked World Bank was found in 1969 by Jeff Gates Perfect all right paste the entire command that generated the correct output into the text field let's do that and we're good okay history when you're working in a reppel it's really helpful to be able to see the commands that you've typed in the past um now to be fair like we're looking here at my
terminal we can see everything that we've typed in the past but there actually is a command that makes it easy to look at everything we've typed in the past it kind of keeps a log of it and that's the history command so it looks like this history and you can see here's the last what's that 15 commands that I Ran So in your shell set two variables Department to engineering so Department equals engineering and then team team equals Ops use Echo to print the following message oops using the department team
variables so we're going to Echo uh I work in dollar sign department on dollar sign tee run the history command and paste its output into the text field now okay and we're good to go now as you can see my terminal is getting a little cramped here I'm all the way down at the bottom of my screen so um we'll Pro the course covers it later but I'm just going to go ahead and do it now going to type clear and just clears up clears up the terminal it doesn't erase my history but it does give me a nice clean window
to work with Okay so you'll often want to rerun a command uh you could just type it again but assuming you don't have the words per minute of the Prime that can a pain and I do not my words per minute is a lowly like 80 even worse when I'm on camera so I don't like retyping commands so instead of typing history again I can just hit the up Arrow key and look at my last uh look at my last command I can also keep typing up and you'll see it's just cycling through all the stuff we've ran in the past and
the down arrow key goes kind of back you know forwards in time Back to the Future so for example if I go Echo one Echo 2 Echo 3 hit up Arrow one it goes to Echo 3 up again to Echo two up again to Echo one and I can go back down to two back down to three and back down to an empty prompt okay and then oh now now we're going to cover the clear command so there we go and we'll answer the question the blank arrow goes back in your history and the blank arrow goes forward uh up goes back and down goes forward another question the clear
command opens a new ter terminal window deletes your shell history from memory or clears the terminal screen it just clears the screen all right terminal Alternatives so like I said I'm on ghosty it's a brand new terminal emulator made by Mitchell Hashimoto the founder of Hashi Corp it's pretty awesome this is like a brand brand new terminal emulator it just came out aside from ghosty I know a lot of people use aacr elac I think that's the the most common one currently my daily driver for text editing is Zed which actually uses
elac onto the hood I'm pretty sure but I just used the the integrated terminal for the most part there's also integrated terminals built into things like VSS code and cursor if those are your editors pretty much every editor or ID does have an integrated terminal though a lot of people don't use the integrated Terminals and then if you use something kind of more command line native like Vim it's much more likely that you're going to use something like ghosty as like full screen terminal emulator because your your you know your
text editor Vim or Neo Vim runs in the terminal so all all this to say pick the terminal emulator that you want to use for this course it doesn't matter you can just use the default terminal if you want check out this lesson and and check out these other terminal emulators if you're curious all right the question which is not a terminal emulator Windows terminal auntu ghosty or AAC uh auntu it's an operating system not a terminal emulator all right on to chapter 2 what is a file system now you're probably
already familiar with the idea of a file system if you've been using a computer for most of your life the idea of folders or directories as they're called in Unix like systems kind of nested within each other in a hierarchy probably already really familiar with this idea so that's I mean at its Essence that's what a file system is it's this tree of directories starting at a root directory which contains other directories and they can kind of go I mean they kind of go as deep as you want that's not entirely true um we don't
have infinite uh space on computers but you know they can go pretty deep and directories just contain other directories and other files so directories are just containers that hold other f files and then files of course I mean really they're just binary blobs at the end of the day with some metadata attached to them to tell you you know what's in that binary blob of data a file can store anything it could be an image text file PDF code it it really could be whatever and it's up to whoever's reading that file to interpret
that data and you know use it as intended so when you open your terminal the working directory or the directory that you're in is going to be somewhere most likely it's going to be in your home directory so for example if I run this PWD command it shows me that I'm in/ users SL Wags Lane so slash represents the very root directory if I scroll back up here you can see this very first directory that's just slash users is then like another directory down if I list the root directory you can see I have all these other
directories in my route but we're specifically in users so so and and then within users we're in uh my username specifically so SL users SL Wags Lane all right you've remotely logged into a suspicious employees machine at World Bank First you need to determine where on their file system you are so we type PWD paste the full output of the command into the text field and submit it so we'll just grab I'll do it again and we'll just grab that SL users SL wag Lane PWD is print working directory
shows us where we are paste that in and cross our fingers we got it right when you're working with the command line file paths are the bread and butter of navigation you're probably already used to thinking of files and directories as nested tree structures after all that is what they are and that's how Windows Explorer or finder on Mac display them a file path is just a text-based representation of one file or directory in the hierarchy all absolute file paths start at the root of the file system
which is just the very top directory in the hierarchy from there everything is nested inside a tree of directories with each directory in the file path separated by a slash now if the path you're looking at points to a file then the last section of the file path will just be the name of the file but if you're looking at a path to a directory then the last section will be the name of the directory to give an example in this hierarchy the path to homework.
txt is/ doents school/ homework. txt and the path to the work directory is just SL documents slor okay file paths so the output of PWD or print working directory is a file path and a file path is just a string that represents where we are on a system so again if you're used to graphical user interfaces like Windows Explorer or finder you might be used to kind of visually seeing the tree of files a file path is just a text representation of exactly where we are now of course file paths can be annoying to type when they're super long but when
you're working within the context of a program using file paths to refer to different files on the file system is much less error prone and much more convenient it's all text based so let's break this down um SL user SL Lane the first slash represents the root directory we kind of went over this inside the root directory we have a users directory and then in that directory we have a Wags Lane directory so we're really two levels down from the route jumping into the assignment says time to start digging for evidence if
you're on windows again make sure that you've switched to a WSL um Ubuntu terminal so that this will actually work all right first step is we're going to download This World Bank folder um it's being downloaded from the bootd GitHub and we're gonna unpack it into our current directory so we're in our home directory going to copy this paste it in run it going to type in my password and now I should have a world Bank directory so if I run LS uh you can see everything that's in my let me clear this up clear LS this is
all the stuff that's in my home directory and now you can see there is a world Bank directory there as well so we're going to change directory into World Bank which is the CD command now here's just a little trick I think we cover it later in the course but you're going to see me do it doing it and wondering what I'm doing if I start typing the name of a directory in the current path and then I hit tab it'll autocomplete so the only directory in my current directory that starts with w RL is World bank so I hit
tab it Auto completes I can change directory into World Bank I also could type it all the way out uh nothing wrong with that either uh this won't work because I'm already in World Bank but you see how that works um and now you can see uh my prompts a little different notice that my shell is showing me that I'm in the World Bank directory now whereas before I was in the home directory okay now within World Bank use the ls command again to see the contents of the World Bank directory so LS for list and we can see four different
things paste the cons output into the text field me your answer okay so we just copy and paste by the way I'm going to fix this after I record this video I don't think that go dood should be there it's not going to break us submitting the assignment but if you're doing this later and it's gone it's because it wasn't supposed to be there and I removed it so don't be alarmed if the go mod is no longer there all right moving on parent directories the CD command changes directory to move into our
directory we went over that um but how do you get back out right so we we changed from our home directory into World bank now we want to get back out we can do CD do dot so dot dot is basically a special Alias for going back up a directory uh one single directory level okay so navigate back out of the World Bank directory we just did that uh so that you're in its Parent Directory uh which in our case is our home directory uh then run the ls command again but pass in the name of the World Bank directory as an argument so if I
just type LS from here because I'm in my home directory I see everything that's in my home directory if I want to see what's in World Bank I could CD into World bank and then run LS which by default prints the current directory or I can pass in an argument to LS and say no you know what I want to specifically list the contents of world bank and then we just copy and paste this again moving on absolute versus relative file paths so so far we've been mostly dealing with relative file paths they're
file paths that are relative to where we currently are so my current working directory is/ users Wags Lane World Bank like lsor bank that's a relative path because I'm saying I want to list the contents of the World Bank directory you can find it relative to where I am currently SL users Wags Lane is an absolute file path because it's giving us the full path from the route so the difference is absolute file paths will work no matter where you are on the system because they can always be traced back to the root they can kind of start
from there and then go forward a relative file path depends on where you are it's kind of like you can always give someone your address to your house and it doesn't matter where they live they'll be able to find your address because your address is absolute right you can tell Amazon your address they can ship a package to you when you're out walking with your friend to give them directions to your house you can say oh my house is up two streets and around the corner that's a relative Direction it depends on where
you and your friend are standing at the moment it's a great way to give directions but you can't tell Amazon oh my house is up two streets and around the corner it doesn't work like that okay so all of this just basically explains that so the tell is that an absolute file path always starts with a slash because it has to start from the root whereas a relative file path will not start with a slash and it will kind of go from where you're at currently let me show you what I mean so I could do cd/ users Wags Lane slor
Bank that'll work that's an absolute path if from here I try to get into the World Bank directory CD World Bank it won't work because there's not a world Bank directory inside of the World Bank directory where we are but if I go up a level now because there's a world Bank directory here I can use a relative path to get back into it cool all right so which one should you use well it depends uh generally when you're just like working on in your terminal uh like this you have a working directory you're
going to do stuff uh let me clear this up you know you're going to do stuff relatively you're going to list some files you're going to CD into private you're going to work in a relative way um absolute paths are much more useful when you're doing like systemwide stuff and you need to know exactly where stuff is on your system or when you're like installing programs you need to know where that program installed on your system so that when you need to run it you know where to find it when you want
to remove it you know where to find it and let's answer the question which is a relative path well it's the only one that doesn't start with a slash all right another question which path will refer to the same file regardless of the current working directory that would be an absolute path again the only one that starts with a slash there we go files okay you're probably familiar with the concept of files from using a Google a guey like Windows Explorer finder and at their core files really are just Blobs of data it's tempting to
think of files as something more like a lot more specific than that you know file types and file metadata and like that stuff exists but it's important to understand that like when you peel back all those layers a file really is just kind of a blob of bites uh that your file Sy system keeps track of it keeps track of its location so you can go find it using a file path so uh the cat command is used to view contents of a file really weird right cat what um it's because cat is short for concatenate which again what uh what does
concatenate have to do with printing stuff well it's called concatenate because you can like print the contents of two files and smos them together concatenate means to put things together when you concatenate two strings you sort of add them end to end and so for that reason it's called cat it's really weird most of the time in my experience you're catting a single file which makes the name a misnomer because you're not you're not really concat you could argue you know you're concatenating the file
to like standard out or something whatever point is you use cat to print the contents of a file or multiple files that's like bottom text what we're doing here okay so use the CD command to confirm you're in the right place we want to be in the World Bank directory all right let me go back up to World Bank use LS to confirm that you're in the right place I am you should see a public directory CD into that let's go into public um you should see a file called PR ideas. txt let's take a look
there it is PR ideas. txt uh use the cat command to view it's context cat PR .txt lots of text in that file cool it's a plain text file paste the context of that file from your terminal into the text field and submit it very good good earning all sorts of awards next one all right head and tail now sometimes you don't want to print everything in a file files can get really big uh this is very true worked on a lot of servers servers like to keep log files and log files can get really really really big so catting the log
file uh I mean your terminal might not be able to render all the text fast enough you can just sit there rendering text waiting terminal Scrolls it's unfortunate so that's where the head and tail command come in uh the head command prints the first end lines of the file where N is a number you specify and if you don't specify a number it default 10 so uh and then the tail command does the last uh number n number of lines of the file okay time to start investigating the Main's transactions so CD into World
Bank private transactions so let's go back up we're going into private transactions run the cat command to view the contents of 2023 CSV so cat 2023 CSV as you can see there's a lot of stuff in here like a lot of stuff really annoying to deal with that many lines of text use the head command to print the first six lines so we'll do head dashn 6 and 20 23.
CSV now we get a nice six lines in fact Let Me Clear and do that again there you go those are the first six lines looks like we're doing six lines because the first line of the fil is the header see these are these are columns in a CSV a CSV is like a text only representation of like an Excel spreadsheet basically or like a Google Sheets document all right then use the tail command to print the last five lines okay tail dasn five 2023 CSV all right submit the combined first six and last five lines for a total of 11 lines all right let's do that and
that and there we go more and less the more and less commands let you view the contents of a file one page or line at a time As the adage goes less is more and it's kind of funny because in this case like less literally is more in the sense that like the less command is is kind of just the more advanced version of the more command um which was kind of a tongue and cheek naming thing but basically the only reason to use the more command is if you don't have access to the less command and it's very likely
that you do have access to the L command it's not like it's you know come out in the last 3 years or something so less is the only one that we're going to worry about okay the assignment says you found nothing suspicious in the first and last transactions of 2023 but we are not done yet it's time to dig through the middle of the file as well run less and pass in the path of 2023 CSV all right less fact Let Me Clear less 2023 CSV notice that you're now in an interactive mode and you've lost your shell prompt this is
true if I'm hitting if I hit enter it just moves me down the file and that's because less has taken over your terminal window this is how a lot of terminal based text editors like Vim or neovim work it's you know you run neovim and you get into this sort of interactive mode in your terminal you lose your prompt while you're in the program okay press enter a few times to scroll down cool just to see how that works uh press Q to exit the last program by the way that's true of a lot of terminal programs where you press Q
to quit not true of Vim that's why leaving Vim is really hard so press Cube rerun the less command but this time pass in the dash n flag to show line numbers all right less- capital N 2023 CSV cool now you can see we got line numbers over here on the right hand side kind of convenient uh you can use the space bar to scroll down a page at a time and you can go back up by pressing B Okay cool so if we want to go whole pages at a time that's really nice can move a lot faster all right find line 153 uh it's right there oh that's so
awkward it's right there at the end my page I can use space though oh back back back back space damn it I want it in the middle of my screen whatever whatever it's right here it's fine it's good enough copy and paste the contents of that line into the text field and submit it all right moving on touch the touch command updates the access and modification timestamps of a file it's like touch update by default if the specified file does not exist touch will create an empty file with a given file name
because of this side effect you'll often see this command used to quickly create new files so again this is one of those things where it's like you know it's the command is named something but it's often used for something that's like there was probably a better name for that like cat you know like maybe print would have made more sense than cat but like there there is a valid reason for the naming but it's just like not always what you use it for um touch is that way like I pretty much only use Touch to
create new files like I said it it does have this uh side effect of updating metadata specifically modification timestamps that's useful if you're like writing you know automations and you need to do that but again most of the time I'm just using touch to create a new file all right uh so to do it you just touch type name of a file it'll create the file uh the file will be empty okay you discovered a discrepancy with the credit card files World Bank is supposed to be keeping credit history records but they aren't there change
into World Bank public products credit cards all right so CD dot dot SL do dot this will take me up two directories um we're going to go back down into public products credit cards create a new file called credi history. txt so touch credit history. txt cool so now we use LS to verify that the file was created there it is credi history.
txt paste the contents of the credit cards directory into the text field so we just grab this whole thing and dump it into the input all right as we mentioned before directory is just a location in a file system that can contain folders or can contain files in other directories on some system directories are called folders looking at you Windows uh but it's the same thing so the makeer make directory command uh creates a new directory inside the current directory so during our digging we found that a file appears to be out of place make
sure you're in World Bank public products credit cards we are let me print work working directory World Bank public products credit cards we're good to go go back to the products directory so see dot dot now that we're in the products directory we'll create an Investments folder so maker Investments Investments list the contents of the product directory again to confirm it was there there it is Investments paste the contents of the product directory in all right good to go all right the move command moves a file directory from one
location to another you can also use it to rename a file or move it into a different directory altogether if you think about it moving a file from One Directory to another and renaming a file from the perspective of file paths is basically the same thing and in a graphical interface that's not necessarily obvious right you have to like drag the file into another folder to move it whereas renaming it you can just like type in the new name but when you're on a command line it you realize it's basically the same thing all we're
doing is changing the file path sure that file path has directory that are changing but like all that's happening is we're changing the path um and so the move command basically lets you change the path of a file and it doesn't matter whether you use full file paths or relative file paths both will work so move the T bills.
txt file from public products credit cards T bills into public products Investments that's because T bills are not credit cards they are an investment okay so from here we've got credit cards invest directories so we can do move uh credit cards T bills to Investments now if we just do Investments uh as a directory it will automatically move it into that directory and keep the same name but just you know because I'm the way I am I like to be explicit I'm just going to type out the whole thing so we're moving it from credit cards T bills. txt into
Investments T bills. txt list the context uh contents of Investments and paste the output into the text field good to go all right the remove command deletes a file or empty directory very straightforward uh and the dashr flag removes recursively which just means that it'll go if if you try to remove a directory recursively will also go remove everything that's in that directory it's what happens by default if you're like in Windows Explorer or finder and you deleted directory by default in those graphical interfaces it
will delete everything that's inside the directory as well as the directory itself on the command line it'll yell at you and say you can't delete a directory unless you use the- R flag it's kind of a safety mechanism because you know there could be 500 things in there did you really want to delete them all so you've got to use the flag okay change directories to World Bank private so we need to go up to here and CD to private use the cat command to view the contents of the password file so cat
we're in private so passwords password.txt why did I CD I meant to no I C it okay we're good I C it I C it all right there's a big problem here it looks like someone is storing passwords in plain text oh look at all these passwords delete both the passwords directory and the passwords txt file within it so let me show you what I meant so if I do RM passwords passwords directory can't do that so we got to do rm- R passwords now the directory and the file is gone list the contents of the private directory we
just did that and we're going to paste its contents into the input field and move forward okay the copy command does what you would probably expect it copies a file from one location to another so whereas the move command like removes the old file path puts it in the new file path this one will create a copy and then you can also copy a directory using the- R flag of course confusingly with the copy command it's a capital R whereas with remove it could be a lowercase R take a look inside the World Bank private transactions directory
should see a few files containing transactions from different years all right so should we just CD there let's just CD there CD uh private transactions LS all right got some different years in here look inside the backup directory LS backups okay something's missing what are we missing 2020 2021 2022 2023 looks up like we do not have a backup of 2022 okay copy the missing file from transactions into the backups directory all right so CP 2020. CSV into backups 2020.
CSV now if we LS backups it's got all four list the contents of backups we already did that and paste it in home I've already kind of mentioned the home directory a little bit but now we'll talk about what it is so in a Unix like operating system again like Mac or Linux a user's home directory is the directory where their personal files are stored it's also the directory that the user starts when logging into the CLI for the first time which is why at the beginning of the course we started in
home which is why the World Bank directory is inside our home directory personally I recommend doing all your Dev work inside your home directory my personal convention uh you can actually see it if I go if I go here um I've got this workspace directory all my coding projects go inside my workspace directory helps me keep everything organized I don't have them kind of spread out all across my machine keeps all my coding projects in one place your home directory is where you want to spend most of your time already kind of
mentioned this and it can actually be dangerous to work in like other root level places on your file system places like /bin SL Etsy like the system uses those for specific things so you don't want to go like putting your you know cat photos in there if you can avoid it and you can avoid it okay so the Tilda Alias so my home directory on Mac is located like I said at/ uswag Lane the Tilda character is an alias for your home directory this is true on both Mac and Linux um so if you want to go home you can always type CD Tilda Tilda you
might not be used to typing Tilda It's Perfectly Normal it's a weird character uh it's just to the left of the one key at the top of the keyboard it's the shift version of back tick so anyways and like I said it's the Alias for home so what is the question here what does the file paths Tilda workplace slam.
CSV so this is important like we talked about absolute file paths start with a slash because slash is the root Tilda slash is not the root it's an alias for your home directory so this is a workspace file nope this is a names. CSV file in a workspace directory not in the root directory names. CSV file in a workspace directory in the home directory names.
CSV file in a workspace file in the home directory grep is very powerful we're going to kind of briefly go over it but it is it's a really powerful tool and we're going to go over the Basics but it's something that you can just like always get better at using um and we'll even go into like chaining it with other commands uh later in the course but okay so you might be used to nice graphical interfaces allow you to search for text and files so if you've ever used contrl F in a Word document or in your browser
or command F if you're on Mac it's how you can find text right super useful you've probably used it before I hope the grep command is basically the the C's version of that and it has tons of capabilities we'll just be kind of going over the simple stuff so the most basic usage for grep is to search for a string in a file for example if we wanted to search for the word hello in a file called words.
txt we just run grep hello words.txt and it would print out every line in the text file that has that text that word hello in it applications often write their logs to files on disk these logs can contain useful information about what the application is doing and can also be used to debug problems as a security auditor you need to dig through these logs to find any evidence of suspicious activity use the GP command and to find any lines with the text critical all caps in the World Bank private logs 2024 0110 log all right so World Bank private logs so let's just go
back into World Bank we're going to do GP we're grepping for CR critical that's the text that we're looking to find and then we'll pass in the path to the file that we want to GP within in this case private logs 20241 10. log boom four lines now just to show you what the full length of the file is let's just cat it so cat private logs 20 24110 log it's huge right it's very common use case for grep in production as assist admin backend developer whatever looking through logs super
useful can GP and find the stuff we're looking for cool um paste the output of the grap command all right graphing multiple files you can also search multiple files at once for example if we wanted to search for the word hello in hello.txt and hello 2.txt we just pass in the names to both files all right and then recursive search we can also search an entire directory again we just have to use that dasr flag to say we want to search recursively and then we pass in a path to a directory and Dot is a special
Alias for the current directory so Tilda is a special Alias for the Home Direct Dory dot dot is a special Alias for one our Parent Directory the directory up one level from where we're at and Dot is the Alias for the current working directory use the grap command to find all the lines with the text critical in the entire logs directory so now instead of this specific log file we're going to look at all the logs so we're going to gp-r and we're going to pass in dot for our current directory wait no
we're not no we're not no we're not because we're not in the logs file so we're going to do pivate SL logs because that's the relative path to the logs directory there we go and as we'd expect we got some more because now we're looking through more log files and then paste the output cool yay all right the find command it's easy to get these mixed up when you're new to the command line grep is for finding text within a file find is for finding the files themselves so with
find we can find a file by name first we pass in a directory and then Dash name the name of the file we're looking for uh we can also do pattern searching so star is a wild card so this this command says find inside of the sum directory directory any file that ends in txt because star could be anything so it would match things like hello.
txt python. txt anything. txt it's going to it's going to match all of those or if you're looking for for example just a word in the file name you could do star name or word that you're looking for Star again so it's like the file name can be anything Chad anything super useful all right you've been tipped off that fraudulent activity seems to happen often with joint accounts joint means accounts that have more than one owner use the fine command to search the World Bank public products directory for all
files that contain the word joint okay so we're going to go find we're searching the World Bank public products directory for the name of files where they contain joint so that means it could start with anything then the word joint and it could end with anything looks like we got four of them paste the output of the find command in there we go let's go chapter three users so Unix like systems uh like the one that we are using again Mac or Linux for the most part they support multiple users so as we've seen I'm logged in as Wags Lane
that's my user a bit of a history bit here you know it's pretty common that you're the only user on your machine like if you own your own laptop you have your own work computer very likely you're the only user on that machine in kind of the modern world we've pushed a lot of user accounts to the network right so you might have a user account on a website or on a local server but maybe you just have your one account on your local machine but historically it was really common to have multiple user
accounts on the same machine I mean it still does happen it's just you know maybe not the case if you're using a personal computer long story short the permissions that we're going to talk about here in this section are the permissions of the user on the machine so like what am I allowed to do as Wags l like that's what we're talking about here and again it can be a little confusing because like if you own your own machine it's like well it's just you so you should have permission to do
everything and generally speaking you do but there's kind of this this exception with the root user which we'll we'll get to okay covered what users are let's talk about pseudo now it's very important that we pronounce it pseudo and it's very important because that's how I pronounce it um you hear other people pronounce it as sudu and they'll have all these like really pedantic technical reasons as to why that's correct but it sounds dumb and because it sounds dumb I think it's wrong so I
say pseudo what does pseudo do well you may have seen the jokes right where it's like make me a sandwich no pseudo make me a sandwich oh okay I'll make you a sandwich that's kind of what it does at the end of the day it allows you to do things that's like practically what it does it allows you to do stuff that you otherwise wouldn't have permissions to do why does it allow you to do it it seems kind of weird weird that just typing something in front of another command like gives you all these
elevated users well what it does is it allows you to like temporarily become a super user so pseudo stands for sudo which stands for super user do so it allows you to act as the root user very important note here using pseudo does Grant unrestricted access and can risk system damage if you don't know what you're doing so generally speaking you shouldn't just like run commands as pseudo the naive thing might be like oh well if like I just want to be able to do everything I'll just run everything
with pseudo that can cause problems because it doesn't just elevate your permissions it also acts as again the root user okay let's demonstrate that so if I type who am I I'm wag Lane if I type pseudo who am I first I get prompted for my password and also it's important to understand that's part of the security mechanism you can't just act as the root user anytime you want to on any user account you have to have the root password all right now I'm root right copy and paste the output of the
command very good in a Unix based operating system like Mac OS or Linux all files and directories have a set of permissions associated with them now there are two ways that we break down those permissions the first is who has the permission the second is what permission do they have now in regard to the what any user accessing a file or a directory may or may not have access access to read it write to it or execute it now all of those permissions both The Who and the what are represented by a 10 character string the first character is
always either a d or a dash if it's a d all that means is this is a directory if it's a dash it just means this is a file the next three characters R WX represent the three permissions that we talked about read write and execute and The Who that they they apply to is the owner of the file or directory the owner is usually just the user that created it but it can be changed manually now this rwx section can have several different states each permission can either be granted in which case the letter is
present or it can be a dash in which case the permission is not granted so for example rwx means that the owner can read write and execute while r-x means that they can only read an execute but not write and r d Das means that they can only read finally this set of rwx permissions is just repeated twice more the next set applies to the group instead of the owner and the last set applies to everyone else so to break down a full 10 character string let's take the example of d rwx r-x r d d the d means that this is a
directory the rwx means that the owner can read WR and execute the r-x means the group can read and execute and the r-- just means that everyone else can only read this directory okay so pseudo allows us to do stuff because we act as the root user and the root user has elevated permissions what are permissions right well in a Unix like system again Mac OS Linux permissions control what we can do to which files and directories and specifically they're usually usually represented as this 10 character string D rwx rwx rwx okay
let's break down each character really quick the very first character the D is just telling us whether this thing to which we can have permissions whether it's a directory or not so if it's a directory it'll be a d if it's a file it'll be a dash those are the only options really the other nine characters are really broken up into three groups art X artx Art X so the first three characters represent what the owner can do so the owner of that file or directory that's their their permission
set the next is for the group and the next is for everyone else okay so this permission set D rwx rwx rwx says this is directory and everyone owners groups and others everyone else can all do everything they can read they can write they can execute that's what the r the W and the X stand for if a permission is missing it's represented with a dash so for example rwx is all permissions for that um entity right owner group or others rw- would mean not all permissions it would mean that that entity like for example the owner can
read and write but can't execute right so they can read a script they can write to a script change the file but they can't execute the script okay so there are three types of things you can do with a file so just really quickly what is owner what is group and what is everyone else frankly for most of us owner and everyone else are probably the most important I should say they'll probably be the ones you care about the most so the owner permissions generally will apply to you if you're the owner of
the file I mean they'd also apply to someone else if they created the file group permissions I won't go too in depth here long story short you can have groups of users if you do have multiple users on the same machine and that's what those permissions apply to generally speaking if you're just doing local development work on your own machine or even if you're administrating a ser you typically won't need to worry about group as much and then everyone else is exactly what it sounds like it's
everyone else for example putting rwx read write and execute for everyone else just means literally anyone can do all three of those things so that's usually one that you really have to worry about especially if people are able to access your machine over the network like in the case of a web server again this isn't a course on web servers I just want you to understand the permission string and what all means actually like understanding the security ramifications especially for like web servers is really a whole another can worms that I
I don't want to get into I want you to understand in this chapter the permissions you have on your own machine when you're doing like local development and you're installing tools and you need permissions to use those tools okay so what is the question which permissions allow everyone to read okay well it's not this one because it goes owner group everyone else so this is uh everyone else has no permissions here um in this one we've got the owner has all permissions the group can execute and everyone else can
execute in this one we've got the owner has all permissions the group can read and execute and everyone else can just read so it's looking like that one um and then just for completeness sake looks like on this one the owner and the group have rewrite and execute permissions and everyone else can do nothing so it's going to be this one here all right another question which permissions allow the owner to execute all right well this gives all all three groups read only access um this one is owner is read and execute group is read
and execute and everyone else is just read this one is read write for owner read write for group and read only for everyone else and then this one is read right for everyone so the only one of these where the owner is allowed to execute files is this one here changing permissions okay so the chamod command is what let change permissions so you'll probably use chamod quite a bit if you're working on a Turnal it is kind of annoying it's called chamod stands for change mode it would be again this is like one of those
naming things like cat all right as part of your security audit you need to know who has access to the files in the private directory the ls command has A-L option that will print out the permissions of each file and directory in Long format okay list the files in world bprivate so we'll do ls- l uh private so here we can see the permissions get printed when we use the- l flag off to the leand side very useful change the permissions of the private directory and all of its contents so that the owner can read
write and execute the group can do nothing and others can do nothing okay so it looks like right now we've got re write execute for owner RX RX all right so we're going to chamod dasr to get the directory and all of its contents we're going to set the Let's see we want the owner to readwrite next cute so U = rwx comma g equals nothing nothing for group and others is also nothing and then the directory is private okay once you've changed the permissions run the LSL command again to make sure they've updated
perfect paste the 10 character permission string of the updated private directory all right and by we want the if we want the private directory right now we're looking at its contents I mean they should be the same but we can we can just do ls- L here and take a look at the provisions of the directory itself so we'll grab that and paste it in all right so should be very familiar with the idea of reading and writing files reading a file very very self-explanatory right you cat a file that's reading the file same with head
and tail grep these are all ways we read data out of a file doesn't matter which program we are using to read the file right again cat is just a program head and tail they're just programs Microsoft Word is a program the point is if you're able to get the data out of the file that means you have read permissions or you need read permissions to do that and then you need write permissions to be able to change the file or update executing a file is exactly what it sounds like it's like can you run this
file as a program can you send the data that's stored in the file through the CPU as instructions and do something right and it's important that that permission is different because I mean that's basically all the protection you have against malware you don't want files that you don't trust to be allowed to be run that's like how computer viruses spread so um or say that's how they run Okay cool so files with a extension are called shell scripts they're just text files that contain
shell commands so like all the stuff we've been running in our terminal in our shell zsh we could put that in a Dosh file it doesn't even really have to have that extension but the point is we could put that all in a file and we could execute that script and our shell interpreter zsh in you know the case of Mac or bash on auntu will execute the commands in the file and then this is just explaining how to run a program so in order to run a program in a shell like zsh all you need to do is type the file path of the program with the
exception that if the program is in the current directory you do need to explicitly use the current directory Alias which is dot that we covered covered a while ago um if it's not in the current directory then you don't need to worry about that that/ prefix all right on to the assignment so there seems to be a suspicious script in the World Bank private bin directory called gen IDs let's go there gen IDs there it is run the following commands in World Bank private bin chm mod-x gen ID okay jamod j-x gen
IDs um that removes the execute permission Let's test those permissions try to run the script let's run gen IDs permission denied right because we removed our own permissions to run it okay so that error occurs because the executable permission is not set for you or user the owner Wags Lane in this case let's read the executable permission so chamod plus X gen IDs this is very important um as a developer you'll run into this all the time where you download a script from online or you write a script yourself and you save the
script or the file or the program and then you go to run it and you get permission denied and so many new programmers like permission denied like what what what what what what they go to stack Overflow and they're Googling things it takes a while to figure out 99 times out of 100 you just need to chamad plus exit just chamod plus X chamod Plus x file name um that'll give the user you're currently acting as permissions to execute very very useful use it all the time okay so once we've done that
let's just run it again and it runs perfect uh paste the output of the script into the input field and submit deal root user okay so I kind of talked a little bit about the root user I skimmed over it let's talk about what it actually is and here's that XKCD that awesome awesome XKCD comic that I was referring to earlier the root user is a super user right super user do uh it has access to everything on the system and can do anything when you use the pseudo command you're running as the root user
as long as your system hasn't been configured differently just like everything in programming there's always weird exceptions but generally speaking that's what's happening uh the pseudo keyword is convenient because it quickly gives you elevated permissions to run a single command so like you can actually change to the root user like permanently in your shell session but usually you don't want to do that usually just want to like run as root for for a second so however it can be dangerous because it
gives you access to everything if you run a command with pseudo that you don't understand you could do serious damage to your system for example RM with the R and F Flags so rm-rf let me clear this up rm- RF or if you're gen Z rm- real um will delete forcefully and recursively so if you do RM dfr or RF uh Slash this could delete literally everything on my machine including all the system files that my operating system needs to run so like don't do this now luckily I'm not even going to try it cuz like this scares me um L if I
ran this it probably nothing bad would happen because there's safeguards put in place that that basically like stop you from doing this and like give you an additional prompt for example in a lot of systems you need to use the dash dash no preserve root flag in order for it to work and when we didn't put this in here A bunch of people hopped into the course and were're like um actually you need to use the flag it's like okay yeah but just don't do it like just don't just don't do it right good to know good to
know RM - RF very dangerous and you would need to as the whole point of this lesson is is pseudo rm-rf slash that's the really scary one again there's still some safeguards but like the point is pseudo will let you do crazy dangerous things so just be careful all right let's answer the question uh which is a super user root Chuck Norris administrator admin it is root you can think of root as like the actual user and super user is like a type that gives it that gives root is a type root is an instance of a super user
super users have elevated permissions uh the next question is what happens if you run pseudo rm-rf slash uh your computer will be wiped clean of all files including files needed function yeah your computer will WIP clean of all files but will still function normally no probably not you will lose your collection of dank memes everything else will be fine wrong uh somewhere in the world Linus Tal's Chuckles that might happen but no the computer clean all files included files needed to function again with the caveat that maybe you
need that no preserve rout flag that's kind of a newer thing you didn't need that on older machines Chon okay so if chamod changes permissions Chon changes owner so when do you need to use pseudo well chamad allows you to change the permissions of any file directory that you own but it would be kind of weird if you could just change the permissions of files that other people own like that doesn't make any sense right like you need to be authenticated as a user in order to change permissions for that user's stuff right so that's what
that's what Chone is for it's for it's it allows you to change the owner of a fileer directory so let's see what this looks like in practice where are we we need to go into the private directory can I make this any bigger oh I can make it a little bigger look at that go into the private directory uh take a look at the context with ls all right see a directory called cont contacts there it is take a look at its contents LS contacts there's an emergency.
txt file in here uh let's cat it cat contacts emergency all right looks like there's some emergency contacts in here H it seems like it has some personal contact info for employees we don't know whose this is but we're pretty sure it should have access we we're pretty sure it should have access strictly limited okay let's change the owner of the entire contacts directory to rout got it so because this is an important file instead of my personal wag Lane user owning it we want root to own it so we're going to do that so
first I'm going to go ahead and ls- L and you can see the contact directory is owned by me so we got permissions over here to the left and then we've got the owners and by the way if you curious about group I am part of the staff group the staff group um that's why that's showing here okay so we're going to go ahead and change it to Roots so pseudo change owner recursively because we want contacts and everything in the contacts directory and we're changing it to root and then the path the path to the um
directory itself going to need to enter my password because I'm acting cool uh now if we LS dasl again it's changed and everything inside should be changed as well well we're going to get to that we're going to get to that pretend I didn't just do that we're going to get to that okay okay based only the line from the output that represents the contact directory all right Boop copy that into the input all right before you start this assignment make sure permissions on the World Bank private contact directory are
drwx that the owner is root and that you're not signed in its root so we should be good here right let's just go through all of that again just so that you can kind of follow along so ls- l so contact directory it's has drwx as the permissions the owner is root and who am I I am wag Lane I am not root okay so we're good you've told senior staff about the contact directory and its contents and they've decided to delete it entirely entirely go ahead and try to delete the contact directory with the RM
command so rm- R for recursive contacts permission denied as expected it's failed to delete because we are no longer the owner and if we look at our permissions only the owner has write permissions to be able to delete the file we are now essentially part of other well actually that's not entirely true we are part of the staff group but also the staff has no permissions so the point is we have no permissions so let's try again using pseudo because if we act as root I mean root is the owner so we
should be good to go uh pseudo rm- contacts deleted once you confirmed your read it run the ls command from inside the private directory paste the output [Music] Tada a program is just a bunch of instructions written in a way that a computer can carry out and in a nutshell there are two kinds of programs compiled programs and interpreted programs for our purposes the real difference between the two is just that compiled programs do not rely on any other programs to be able to run they're usually written in a
language like see rust or go but are then compiled down to Binary the raw language of your computer's Hardware interpreted programs on the other hand do require other software in order to be executed python Ruby JavaScript or shell scripts rely on an interpreter to read the code as they run when you run a program on your machine that has no other dependencies it can simply be ran by typing the name of the program into your shell however when you run an interpreted program you need to tell your machine which interpreter it should
use for example to run a compiled program called text editor you might just type text editor to run an interpreted Python program you might have to type python text editor. Pui and that's because the first one is a compiled binary it's just ones and zeros that your machine knows how to execute in the second example text editor.
py is just a file of python source code so it needs access to the the python interpreter all right compiled versus interpreted so programs are just set of sets of instructions that a computer can execute and sometimes we call those programs sometimes we refer to the programs themselves as executables an executable can be like a thing like an actual program it can also like be an adjective to describe something like it's executable we can execute it um so it could be a noun or an adjective but the point is sometimes the words program
and executable are used interchangeably and broadly speaking there are two types of program there's compiled programs and interpreted programs compiled programs just means any program that has been converted to machine code such that it can run directly on your computer's Hardware it's kind of it's the language of your computer's Hardware is probably the best way to put it the instruction set that your computer CPU is designed to execute that's the format of the file and it's not human readable
ever basically um it's it's ones and zeros it's binary you'll also sometimes hear compiled programs called binaries like hey can you run that binary it's a way people talk about compiled programs sometimes interpreted programs on the other hand I mean they're still they still run through your CPU at some point but they're not compiled to natively run on your Hardware there has to be another program running that interprets the code typically interpreted programs run a little bit slower but they also have some other
benefits like like sometimes they're more cross uh platform because they don't need to be compiled to a specific architecture so what's the difference all right and let me give you some like concrete examples so if you've ever played a video game on Windows you're probably used to opening aexe file.
exe files on windows are typically compiled executable files designed to run on your computer's Hardware well again typically there's always exceptions but like that's probably What's Happening Here on Linux and Mac you will not often see the file extension. exe it's not necessar there's like rules against it but you don't usually see that it's not really the convention video games are often compiled programs interpreted programs on the other hand are things like shell scripts like the Gen IDs Dosh that's
that's an interpreted program that is run by the shell programming language in our in my case zsh python is another example when I run a python script you not only have to run the Python program you you need to run it using the python interpreter which is why to run a Python program you you you have to type something like python main.
py typically you have to say hey I want to use the python interpreter to run this file whereas with an executi file you could just run it directly if you're paying really close attention you might have noticed wait I can just run scripts like shell scripts without having to specify an interpreter that's true you don't have to specify it necessarily but there still is an interpreter being used under the hood right in the case of zsh it's The zsh Interpreter let's get to the assignment in your shell run the
following command which whichit sh take a look at the contents of that file all right let's cat /bin/sh ah it's terrible why why is it terrible probably probably because it's a compiled program all this crap is binary data you can see there's some stuff in here that's that uh we can interpret as text but there's a lot of just like binary in here I think so long story short this is a compiled program sh whereas the like gen IDs Dosh script that we were reading before was a script it was just a plain text file these are
both executable programs the sh interpreter and the sh script but the dosh script needs The Interpreter in order to run because it's interpreted okay answer the question what is the output of catting the sh executable um raw binary encoded as text in h decimal Rob baring encoded as texts in ones and zeros nothing a bunch of gibberish rites attempting to be interpreted as text it's mostly this mostly mostly a bunch of gibberish next question which can be executed without the help of an interpreter a shell script like genid
Dosh no it needs the sh interpreter a compiled executable like the sh program yes a python script no needs the python interpreter shebang okay so as we talked about before you can run any executable file by typing its path in your shell like bin gen id. that works out of the box for files that are compiled executables of course but interpreted programs that doesn't always work out of the box for like we mentioned before sometimes you'll need to specify the interpreter but there is this little trick called the shebang where you can
add The Interpreter basically like the first line of the script to say hey when I run this script as an executable from my shell here's where you can go find The Interpreter to interpret it that way you don't need to specify The Interpreter on the command line when you run it so you can specify The Interpreter in the script itself cool so like for example this says Hey use the Python 3 interpreter when I run the script now instead of having to type python python 3 main.
py I can just type main.py and because the main.py file has the shebang as the first line in the file we'd be good to go use the cat command to view the contents of private bin gen IDs so cat bin gen IDs see we got a shebang up here paste the shebang into the input field and submit your answer born shell okay so as we talked about before if you are on Windows then you should be on WSL and you should be on Ubuntu which means you're probably using a bash shell and if you're on Mac you're probably running zsh um older Maxs you
might also be on bash they kind of switched to zsh by default I can't remember a couple years ago if you're running a raw Linux installation something custom then I hope you know what you have because I don't uh so to get handwavy about it I want to explain the difference between bash and zsh like I mentioned the beginning of this course the differences are not so great that you will typically notice if you're just doing like what I would consider like standard web development stuff but the differences will become apparent if
you're doing like a lot of heavy scripting um because they are different scripting languages um okay so what is sh sh is the born shell it's kind of the original the OG shell language um it's the original Unix shell and it's poix compliant which is a fancy way of saying like it it adheres to a strict set of rules that that M that uh kind of ensures that the script will behave in a certain way so like there's certain syntax uh that has to be able it has to support and the borne shell supports
that that syntax and those rules um it's a very basic shell and it doesn't have very many quality of life features so writing really complex scripts in straight sh can get really verbose means it requires a lot of code to do it bash and zsh are newer shells that have a lot of quality of life features so you know when you are writing more intense scripts it can be really helpful to be using bash or zsh because you get kind of additional features features on top of just like your standard posix compliant stuff so bash stands for Born
Again shell and it's generally speaking the most popular shell on Linux um it builds on top of sh but adds a lot of features and then zsh or the zshell currently the most popular shell on Mac it's similar to bash in that it adds extra stuff on top of sh but it's just different than bash okay now zsh and Bash are both sh compatible which means they can run zsh and Bash can runsh scripts they can run scripts that are kind of borne shell or poix compliant they just have extra features on top again for the purpose of this course you
don't need to know big differ between them just know that they are in fact different question blank and blank are a superet of blank they can do anything blank can do and more zsh and Bash or bash and zsh are a superet of sh they can do everything sh can do and more all right shell configuration both bash and zsh have configuration files that run automatically every time you start a new shell session cell shells she shells by the she shore these files are used to set up your shell environment they can be used to set up alias functions and
environment variables so we went over variables a lot earlier we'll talk about environment variables later point is you can it's kind of like have you ever set up something to run on Startup on your computer for example like I have Spotify open every time I open my computer this is the equivalent of that it's like do you just have certain scripts that you want to run when you open a shell session that's what these config files are for they're very useful the configuration files are always located
in your home directory so it'll be specific to a user and are hidden by default so for example if I ls- a my home directory you can see so Dasa shows like hidden files you can see there's my zshrc so zshrc do zshrc sorry is the hidden file the dot means it's a hidden file that's the one that's going to run every time I open up a new zsh shell all right as part of our audit we're trying to figure out what shell commands run automatically when a user logs in on the machine so we need to confirm which
shell configuration file is being used edit the file you believe to be your shell configuration file in our case zshrc and we can use the Nano command to do it so we're going to go Nano home directory. zshrc edit the file you belied to your shell configuration file and add the following line to the bottom so I'm just going to use the arrow keys like a simpleton to go all the way down to the bottom and we're going to Echo hello from the shell and then I'm going to control o enter and contr X to
exit all right close your terminal and open a new one if you see the message hello from the shell you found the right file um do I have an easy way to file does ghosty I'm sure ghosty has an easy way to oh you know what I can do I think I can open a new tab perfect there it is Hello from the shell so right when I opened a new terminal tab which opens a new shell session we got this hello from the shell print edit the bash RC again to remove the line you added to the file okay let's go ahead and do that we
can I don't even know the command in in Nana to delete a line so I'm just going to just going to backspace nice and slowly all right control o save contr x uh now when I open a new tab it's not printed so we successfully removed it all right answer the question what might you rest why might you restart your shell after changing a shell configuration file because the config file runs when you type O Senpai p no because the config file runs automatically when you start a new shell session yes so we talked about how you can
create and use local variables name equals Lane Echo name uh there's another type of variable called an environment variable frankly you'll probably use these more often they're available to all programs that run in your shell so very often you will create environment variables and then run programs that use those environment variables as they run a very common way to configure a program on a server for example you can view all of the environment variables that are currently set in your shell with the EnV
command I'm not going to type it for you because it probably has private stuff probably has some secret keys in there not going to do it so to set an environment variable in our shell we use the export command so the only difference here is that we're going to use the export command and then kind of by convention environment variables should be screaming case all capital letters so for example export name equals Lane Echo name and again the difference here is that programs can read the environment variables I've exported it okay
assignment take a look at the contents of warsh script in World Bank private bin are we in bin we need to go to bin CD bin cat war. sh okay so you can see our shebang at the top and then you can see it's actually using some environment variables here it's looks like it's using one called warn message and one called warn from name so we need to export those before we run it cuz like let's just try running it right now if I just run warn Dosh you can see this line is blank and the from line is blank
because there's nothing in those environment variables so first we're going to set export warn message equals the auditor is here that what do I do export warn message equals the auditor is here what did I screw up zsh bad assignment what am I doing there we go no space is allowed export warn from name equals your worst nightmare now we run it again ah there we go and you can see the variables are used the auditor is here and from your worst nightmare run the script and paste its output into the infil field I can do
that path okay this is one of the most important lessons in the entire course honestly like a big so really the purpose of this course is to get you comfortable using your command line there's a few lessons in this course that are going to come back and help you over and over and over chamad plus X is a big one um just understanding environment variables in general file paths but the path is a really important one anytime you're trying to install tools on your machine and I have seen developers with years of experience
still get confused about their path and what is installed on their machine so let's understand what it is fundamentally so when you do have issues in the future which you will you know how to debug them there are environment variables that are sort of built into your shell and by builtin I just mean there are programs that care care about those environment variables by default kind of like how this warn sh script wanted warn message and warn from name those are weird we made those up for the script there are other environment
variables that like all programs or many programs care about path is one of those environment variables so why do we care about path the path is an environment variable that stores a list of directories any file in any directory in that list can be run straight from the command line without having to type the full path so for example cat is a program right we've been using cat all the time if I do which cat we can see the absolute path SL binat bin is a directory in my path what that means is when I just type cat
without typing the full absolute file path to cat it works because the bin directory is being scanned for executables called cat so when you install programs that you want to be able to use systemwide you want to be able to run them on the command line just using their name from anywhere then the directory that that program is in needs to be in your path let's take a look at our path lot of stuff in here what is it so bunch of absolute paths SL users Wags Lane sl.
bubin colon okay the colons are are the delimiters in your path so this is an absolute path to a directory anything in this directory I am able to execute provided I have permissions by just typing the name of that program into my shell so I don't have to type SL users slag Lane slbn bin slash you know warsh I can just type this case war.
sh assuming it's in there and then we have a lot of those we have a lot of those directories in the path so why does this all matter well a lot of times again you'll install a tool and it'll go somewhere on your machine and that somewhere that directory isn't in your path and so when you go to run it try to run it the machine will say something like command not found and you go why is it not found I just installed it well it's because the directory was installed into is not in your path so as something of a security engineer
yourself let me clear this up you want tempor disable the path variable so that you can only run executables by using their full path you know just so you don't accidentally run something you don't mean to so reset your path variable to an empty string go do that sweet this will only affect your current shell session if you open a new shell it'll still use the default so that's great um try running some simple c yeah let's LS oh shoot can't LS why because the slash bin directory is no
longer in our path so it doesn't know where to find LS I mean same with print working oh print working directory still works sorry there are some that are like truly built in some will no longer work while others that do not rely on the path will then we answer the question after deleting your path what happens when you try to run LS the command isn't found change your path a common problem you'll run into in the future is that you install a new program on your machine but when you try to run it from
your terminal you get an error like command lot found we just talked about this uh nine times out of 10 that's because the program is installed in a directory that's not in your path so when you install stuffff make maybe your apt get installing on aunu right maybe you're Brew installing on Mac maybe you're literally downloading a binary with curl and trying to run it almost always if you're using some sort of installer or package manager during the installation process usually towards the
end of the installation process it will print out where it installed the thing and then it'll say try running the thing using this so many programmers I mean I'm guilty of this as well when you're running like installation commands on your terminal like spits out all this text and you kind of let your eyes glaze over and then it finishes and then you like try to do it and it's like ah command not found you're like ah it's broken you go straight to stack Overflow uh straight to Google or straight to
chat jippy when often in that text it probably told you where it installed the thing on your machine and if you know that it just needs to be in your path then you can just go check like is that directory in my path oh it's not you add it and then you're good to go so that's that's usually how that goes okay restart your cell session to reset your path give me a new new shell session make sure I got my path path back we're good the World Bank directory that you downloaded has some executables that
would be useful to have in your path so you can run them from anywhere add World Bank private bin directory to your path so we're going to go to bin and then I'm going to print World print my working directory this is the full absolute path and now we're going to add it we're going to add it to our path I'm going to do it the manual way because I think that's more important to understand it's definitely more illustrative so export path equals so we're setting the path environment variable and this is
important first we start with the old path so we're saying the new path is going to be the old path plus the colon delimiter and the new directory that we're adding right because if we just set it to the new directory we'd lose all the other directories that were in our path so go ahead and Export that now CD outside of the World Bank directory entirely in fact let's go home CD home now run World bank.
sh so just to show you we LS here you can see World bank. sh is in here so normally to run this we'd have to give the full file path so like World bank. sh like that but now a crap oh wait no I didn't start a new session we're good I just cleared I just cleared we're good but now because it's in my path I should be able to just type worldbank Dosh and it still works even though I'm in my home directory because that directory that it's in is now in my path follow the prompts and copy paste the entire interaction all right enter
my name Lane enter my email ooh I don't want to show you my email Lane gmail.com it's not my email got them all right copy that whole interaction good to go path config in the last lesson you changed your path variable for your current shell session the trouble is the next time you restart your shell it will be reset to its default value you won't be able to use World bank.
sh uh from anywhere unless you change your path permanently so just to show you what I mean if I open a new terminal and run World Bank oh my gosh Dosh wait sorry not slash what am I doing let me just type it out worldbank Dosh command not found new shell session my path environment reset edit your zshrc and add an export command to the end of the file so this is a very common use case for configuration files like zshrc uh they'll have commands in them that modify your path because that's how you modify your path permanently so let's go
ahead and Nano zshrc all right and the instructions say to do to the end of the file it probably doesn't matter where you do it I'm just going go ahead and do it at the end of the file um okay so here we're going to run the same command so export it's the exact same thing we typed into our shell so export path equals dollar sign path colon thing we want to add which oh if I could remember what it is it's users Wags Lane then World Bing private bin and then we'll control o to save contr X to exit all right now restart
our shell session I'm going to use a different method here instead of opening a new terminal window which I could do but you've seen me do that before I'm going to Source the zshrc file this is a way to rerun that file without actually starting a new session now that I've done that my path should be updated let's go ahead and try to run World bank.
sh and it worked what changed when we added the path changed the config file we need to use the full path to world bank. no that would be silly the world bank. script is available from anywhere even after a shell session restart correct the World Bank ass script is available from anywhere but only in the current session no the point of adding it to the config file is that now it's always available so again when you install stuff and then you want to use it day-to-day you're probably going to want to edit your zsh fig uh Z zshrc or bash RC or in some
dros bash profile or whatever okay chapter five okay the man command is short for manual and it's a program that displays the manual for other programs now I know that manuals and documentation can feel scary they can feel intimidating rtfm read the friendly manual it's daunting that's why tutorials and courses and things like this even exist is because reading the manual can be scary but my goal with all of these courses is always to wean you off the handholding slowly over time so that by the time you're
done with the courses you feel really comfortable just looking at documentation and figuring things out on your own that's really what it means to be a professional developer that doesn't mean you can't take courses as a professional developer but it does mean you like shouldn't need them right maybe they can save you time they can get you up running faster but like you should be able to read documentation so using the man command well all you do is type man and then the name of a command now of
course not every command or program out there has a man manual but a lot of the built-ins do so if you're using kind of the the traditional Unix programs there's likely a manual entry so manual itself has a manual entry so man man this is what a manual looks like you usually get this interactive pager we're familiar with this right from the less tool for example enter uh moves us down a page Q quits all that good stuff now most people don't just read manuals for fun like TJ did with the neovin manual
and Sarah did with the bash manual most people don't do that we reference the manual when we need it for specific things so for example I can open the manual open up the manual for the ls command and say I want to know what the dashr flag does uh this is really common you look up the manual for command and to see what flags are available to you type slash to say hey I want to search and then I'm searching for- R hit enter there it is so- R reverse the order of the sort very cool that's what d r does
all right and then I can use n to jump to more results so there's another Das R in here there's another DH R in here great Q quits perfect let's jump to the assignment as a systems person the grep command will be your best friend has a lot of power but it can be a little confusing to use open the grep manual so man GP cool read the first couple of paragraphs of the GP manual and answer the questions I'm just going to rtfm I'm just going to read you the first couple paragraphs all right the name of the
command is grep there's also all these other types of grep egrep fgp cool very good it's a file pattern Searcher this hairy syntax is representative of all the options the things that you can pass into GP not going to cover that syntax right now it's not as scary as it looks um but it's also not really the purpose of this course but this is basically telling us how we can pass arguments into the command and we will cover arguments and stuff just a bit later cool um description the GP utility
searches any given input file selecting lines that match one or more patterns by default a pattern matches an input line if the regular expression re in the pattern matches the input line without its trailing new line an empty expression matches every line each input line that matches is at least one of the patterns is written to standard output so lot of words to say what we we already know which is we can search through a file for an expression a string of text and print all of the lines containing that text out to
standard out grep is used for simple patterns and basic regular expressions bres of course we of course we need an acronym EGP can handle extended regular Expressions EES fgrep is quicker than both GP and egrep but can only handle fixed patterns PS fast grip patterns May consist of one or more lines allowing any of the pattern lines to match a portion of the inbook all right let's go ahead and see what the question is what does the Das V flag do holy crap we didn't even get to- V all right let's
search for it sl-v all right now it's slash it's lowercase V so lowercase V is invert match selects non-matching lines selected lines are those not matching that'll be it getting chests getting achievements awesome all right next question which option is incorrect - t- r- i and- c well let's see what's the first one- C let's look for- C- C is Count okay that looks correct what's i i is ignore case okay that's good then Dash R is recursive okay- t St there's no T there's no
T it's that one cool now we know how to use man all right flags all right now we're going to talk just a little bit more in depth about all those options that we can pass into a command so if you as you've already seen in this course some commands accept flags flags are options that you pass to a command to change its behavior for example the ls command can take the- L flag to show a long list of files right we've been here ls- l or the- a flag to show all files including hidden files ls- a right and you can combine Flags when you
combine Flags you can combine just the letters and you don't need to type extra dashes so ls- Al or ls- a both oops ls- La they do the same thing or you could do ls- l- a again does the same thing cool now whether or not a command takes flags and what those flags are is up to the developer of the command that's why a manual is useful there's no like there's conventions right like dasr often times will be recursive but it doesn't have to be so you need you need a reference or to just test it out now
single letter characters are typically prefixed with a single Dash like ls- a often times there's a more verbose version so let me man GP again so you can see the Das a flag also has a long version which is D- text so typically the long version is dash dash the short version is single Dash um what I recommend is when you're typing the command kind of manually in your terminal you're probably going to want to use the short version like Das a or DB when you were writing a script that calls a tool like this that's when I'd
use the verbos version like-- text or in this case D- bite offset just because it's clear so when someone else reads your script it's it's more obvious that d-b offset has something to do with a bite offset than just-b so you just use dasb when you're trying to save yourself time use the longer one when you're writing a script that maybe you're going to commit to Source control or you're going to share with teammates cool you found that some files have been tampered with to figure out which one it is you
need to know the number of bytes contained in each file use the word count command WC we have we have WC right which word counts under user bin WC cool um to count the number of bytes in the World Bank public PR ideas text file use the man command to figure out which flag you need to use cool so it's man word count we're trying to find a flag that will give us the number of bytes and my eyes luckily just immed immediately saw this the number of bytes in each input file is written to the standard output
this will cancel out any prior usage of- M which I'm guessing is yeah the number of characters Okay cool so by default WC counts words word line character bite count default is words we want bytes let's do it so word count - c World Bank public PR ideas. txt 1098 byes if I don't use that flag then oh actually I get I guess by default I get all of them so 12 words 182 characters 1,98 bytes past a number of bytes into the input field awesome positional arguments okay so Flags the interesting thing about
Flags is that the order doesn't matter we can do ls- again we can do ls- la and we can do ls- A-L it all works positional arguments the order does matter just like if you're familiar with python python functions take arguments and the order Matters by default if they're regular arguments if they're not keyword arguments you can almost think of again if you're familiar with python flags are basically keyword arguments and positional arguments are regular command line arguments so for example the move Command right we
we've already been here or the ls command so LS by default prints the current working directory but it takes as its first positional argument the name of a directory like World Bank okay take a look inside World Bank public directory cat the contents let's go there CD World Bank public cat the contents of key.
txt ooh scary scary private RSA key move it from world banku key.txt to worldbank credit all right so we're going to move um key.txt to do do slash need to up level private key.txt and then we're going to LS the Das Das private LS the private directory and paste the contents in so just again to be clear the move command took two positional arguments the first is the source the second is the destination those are not Flags those are positional arguments paste that in good to go help by convention most production ready CLI tools have a help
option that prints information about how to use the tool very common it's usually accessed with one of the following d-el DH or help very very common it's almost always one of those three things I hope it's never not one of those three things cool the help output is often easier to parse than a full man page yeah so with non like builtin like unix commands like LS cat things like that it's much more likely first of all that there's going to be a help command for it than there's going to be a manual entry that's uh
just just more likely cuz it's easier to ship documentation with the program than it is to like you know get a man page so go there also the help in my opinion usually tends to be more concise so if what you're looking for is fairly simple you'll probably find it e more easily in The Help flag okay you need to make some Network requests as part of this audit you want to make sure that this machine you're auditing only has access to authorized systems to make those requests you'll need to know how to use
Curl it's a CLI tool that lets you make Network request from the command line print out the help menu for curl all right so we're just going to guess I don't even know I'm just going to start with d-el there it is d-el man curl much bigger see lots of stuff in here but curl d-el very simple very concise gives me kind of the simple version of the usage all right paste the command you use to print the menu uh into the input field so we just did curl d-el awesome exit codes exit codes sometimes called return codes or status
codes are how programm communicate back whether they ran successfully or not zero is the exit code for Success any other exit code is an error this is very important zero good everything else bad and nine times out of 10 when it's a non-zero code it will just be code one those are like the two most common codes there zero and one of course there are other codes those are those are the those are the common ones those are the popular ones so you might think like why do I care about these exit codes I can tell whether or not my command just by
looking at the output and that is generally true when you're just like working on the command line but a lot of times you'll call a program in some sort of Automation in our cicd course we talk a lot about this where we're automating kind of command line tasks and exit codes are super important it's how we know whether or not our automation succeeded or failed also it's very common that you'll have one program calling another program for example maybe a server uh like a web server has
one program that automatically restarts the server if it goes down so have one program calling another program and it will look at the exit code of the server program to see whether it like crashed or failed gracefully exited gracefully and know whether or not it needs to restart it and what logic it needs to use to restart it so exit code is very important when we are in the Shell we can access the exit code of the last program using the question mark variable so for example if we just do LS the home directory and then Echo
the question mark variable it's prefixed with a dollar sign because we're just because we're using a variable we get zero now if I LS something that doesn't exist you'll see no such file or directory this actually exited with a non-zero exit code so if I now if I Echo question mark which again question mark is a variable that holds the exit code of the last thing I did it's one cool Now commands will usually exit with error codes if they've been run without the proper arguments uh or configuration
for example our private bin warsh script we'll exit with a non-zero code if we don't provide the required environment variables so let's go check out that script let's go to oops slash private B warn warn thought it wasn't here oh I'm I'm changing D yeah there's warn okay uh if you don't have the required environment varable set so let's run it warn message is not set exiting with error Echo 69 what paste just the exit code in the text box your answer all right 69 let's submit that so this is just to
show that like it doesn't need to be zero or one those are the common ones 69 very odd in fact just really quickly I want to show you cat warsh you can see in the logic of the script right here that's where it's exiting with the code 69 so whoever wrote this script literally just just hardcoded like hey when this happens I want to exit with code 69 all right standard output now you might not know it yet but you're already a pro using standard output we've been using standard output all throughout this
course we just haven't really talked about what it is yet standard output also referred to as standard out or STD out kind of in text when we're writing it uh just to keep it short is the default place where programs print their output it's just a stream of data that when you're using a terminal emulator prints to your terminal it can be redirected to other places but for now when we're just using our terminal let's let's it's simple to think about it as a stream of text that comes back from a
program that we run and is printed to the terminal all programming languages have a simple way to print standard out it's like the most standard thing a programming language can do in terms of input output in Python it's just the print function right and again in the Shell it's just Echo hello world that just prints hello world to standard out which is why it shows up in our terminal assignment use the GP command to print all the lines in World Bank private transactions 2020. CSV that contain the
word Marshall to standard out all right more GP practice so let's go over there are we in World Bank World Bank private transactions all right so we're going to GP for the string Marshall and we're going to grap the file 2020. CSV there we go it printed the lines to standard out copy the output and paste it and submit now standard error usually called St a standard air is a data stream just like standard output so again these are both just data streams they are places where programs can write byes to the
only difference is that by convention it's where we send error messages think like logs or problems the reason it's a separate stream and programs don't just use standard out is so that the caller of the program can redirect the error messages and the success messages essentially to different places very often that you'll want to do that okay so let's talk about actually redirecting the Stream So by default standard out and standard error when you are working in a terminal you're running programs in
your terminal they will print standard out and Standard air back to the terminal but both of them so for all we know if we didn't do any digging to check this could be standard out or standard error now we can redirect standard out in standard error to not go to the terminal to not be rendered in the terminal but instead to be written say to a file you could also I mean you could redirect it anywhere if you're writing your own custom program but like the easiest thing to do in the Shell is to redirect it to a file so for example
Echo Hello World As We Know by itself prints hello world back to the terminal but we can redirect it to a file so me ls- L Echo hello world hello. text notice that it didn't print hello world to the terminal now I ran Echo hello world but I redirected standard out to hello.
txt so I ls- L now you'll see there's a new file here called hello.txt let's cat that it has hello world inside because we redirected output there this is very commonly used in backend development you'll redirect logs to a file so that later you can look at your server logs okay cool I'm going to go ahead and remove that we don't need that now re redirecting standard error works the exact same way the only difference is instead of just this was that greater than sign it's a two and then a greater than that'll redirect Standard air
assignment there is a process transactions. sh script in the World Bank private bin directory let's see where are we we are in World Bank private so go up a level there we go it accepts a path to a transaction action CSV file as a positional argument CLI argument cool so if I run wait process World Bank private I need to go to the b c b LS all right there's process transactions okay so it accepts the csb file it prints modern transactions after the year 2000 to standard out and old transactions before
the year 2000 to standard error interesting run the script and pass it the path to 2020. CSV okay so we're going to go slash process transactions remember we need the SL because we're running a script in our current directory pass in 2020. CSV oh which is in transactions so do SL transactions 2020.
CSV okay redirect standard error to a temporary file okay so two greater than sltm pworld bank. log /tmp is basically a special place in your file system for temporary files if you need a temporary file put it in there there's certain logic that runs that assumes that those are temporary files so it might get cleaned up later automatically so you don't want to put like important stuff in there but if it's if it's think of it as like a kind of a scratch pad and then I think we run it boom all right if you're missing 2020. CSV made a mistake in the previous
step we ignore that we didn't we don't make mistakes uh ensure the files in transactions match the files in transactions backups if not make a copy again we don't need to worry about that okay cat the file we just made so if we ls- TMP not LS cat let me clear so you can see this better cat tmpw bank.
log boom these should be the transactions that happened before the year 2000 as you can see 1994 1995 1999 awesome paste those transactions into the input boom standard in all right there's a standard output there must be a standard input right that just makes sense standard input usually called standard in or STD in it's the default place where programs read data now it's it's important to understand the standard in is not the same as positional arguments positional arguments they're just read once when you call the program same flags flags
are arguments it's not the same standard in is a stream that is read from as the program runs again all major programming languages for the most part provide a simple way to read for standard in um and in Python it's just the input function so if you run this python script says what is your name um the program will actually stop and wait for the user to type something into to their terminal they will get a prompt um and is then passed in through standard in cool um so the program basically blocks and reads from standard in until
it gets a new line which is what the enter key sends okay run the worldbank private bin World bank. sh program again okay is it in here Ben World nope I forgot the Dot World Bank welcome to your world Bank CLI tool please enter your name um take a closer look at the code oh wait I I need to read the thing run the program again notice that it makes use of standard in to read your name and email ah okay so please enter your name the script is now waiting waiting for input from standard in specifically it's
waiting for a new line so it's going to capture what I type Lane in this case and then when I hit enter I send a new line through standard in the program reads that and goes ah I got the end of the input cool keep going keeps executing the program until it prints out please enter your email now it's going to wait again it's waiting for more standard in um put my email in Lan gmail.
com finishes the program now name is Lan your email is this cool take a closer look at the code all right let's cat World bank. sh what command does it use to read from standard in so let's just read this script so the first thing it does is print the console welcome to the World Bank CLI tool then it prints please enter your name and it uses the read command read name so this in in our shell language is saying stop and read from standard in right and wait till you get a new line and save that variable or save that data
sorry that string into the name variable then it does the same thing with the email so it's it's that read command there uh copy the command's name into the input field and submit your answer cool it's read piping when one of the most beautiful things about the shell is that you can pipe the output of one program into the input of another program with this one simple concept you can run powerful automation tasks the pipe operator is how we do that it's this character that looks like a vertical
line uh you're probably not used to typing the pipe operator um it's probably right above your Enter key um it's you it's like the shifted version of the slash it's right above your your Enter key um the pipe operator takes the standard out of the program on the left and pipes it through into standard in of the program on the right um so for example we know that word count can be given a file to count words but like most Unix like tools it can read from standard in as well so for example echo
my name is Lane rather than allowing that standard out to go to the terminal which is what it does by default or redirecting it to a file we're not going to do that we're going to pipe it instead to the word count program you can see this is oh I think I misspoke earlier so this is lines this is words and this is characters which will typically map to bites um assuming asky characters okay so um echo my name is Lane word count yeah we got all that assignment we need to figure out how many transactions Bob has been
involved with Bob is looking sus use the GP command to find all lines in all of the transactions that include the word Bob all right so we need to grip for the string Bob um it says all the transactions so we need to do recursive which is a capital R um path to the transactions directory which is transactions yep and then we need to exclude excluder um we'll actually need to use a relative path here as well do do slash transactions transactions I spell that right backup o did I do that right oh and then pipe the output of
that command well let's see if that works first of all it did something maybe it worked I see Bobs in there that's good do I see multiple files see a lot of 2022 question is is there any backup I think we're good we'll just send it we'll just send it all right um let's pipe that into wc- l let's count the number of lines all right we got 3,973 let's see if we did it right I'm not super confident I kind of sped through that and we got it interrupt sometimes a program will get stuck and you want to stop it common
reasons for this are you made a typo in the command it's not doing what you want uh it's trying to access the internet but you're not connected to the internet it's processing too much data you don't want to wait for it to finish um there's all sorts of reasons that you're going to want to kill or stop a command that's not responding if you've ever used windows task manager you understand programs they hang uh they they freeze sometimes you just got to kill it right okay so in those cases where the program
is hung you can stop the program by pressing contrl C what this does under the hood is it sends a Sig int signal interrupt to the program which is supposed to listen to that signal and stop now we'll talk about later how that sometimes doesn't work but it usually works so inside the World Bank private bin directory there's a program called malicious.
sh do we see it there it is clearl m.sh there it is um as a good security auditor and knowing that you are on a secure system with no internet access you want to see what this program does go ahead and run it all right it's doing scary oh it's doing scary things and I have if I press enter it just keeps doing it right um if I wasn't good with a terminal I'd think I'm stuck but we can run contrl C program exits and you'll notice it actually printed a special thing here that's because it was waiting for sigint
and when it received sigint the logic of this script says when I receive Sig print malicious skull dugery complete and exit Okay uh paste the last line of its output into the text box so we'll just grabb this and paste it in cool kill okay remember how I said sometimes programs don't exit uh that's what kill is for um sometimes a program is in such a bad state that it doesn't respond to Sig in which case the best option is to use another shell session or a new terminal window to manually kill the program all
right so let's uh let's go over this so the kill command takes a PID as its first positional argument PID stands for process ID um which is the ID given to it by the operating system so that uh well it's an idea given to it by the processing system or by the operating system uh and we're going to need to use that so the kill command knows which process to kill cool how do you find the process ID you use the PS command with the aux options which just means show all the processes including those owned by other
users and show extra information about each process usually when you're looking for a proc uh for a usually when you're looking for a program to kill you want to use these three flags um or these three arguments um again this is very similar to like if you've ever used Windows Task Manager um or what's it called on Mac uh do I have it written down on here somewhere in Mac it's I can't even remember that's embarrassing I don't know there's some there's something the one that lets you
kill the programs task manager on Windows I don't know I'm always having to kill games cuz they freeze um so anyways let's uh let's jump into using it so you did some digging and found out that the malicious program actually has another mode Force run the program again in Force Mode okay malicious.
sh Force Sig ignored due to force argument very scary um try to kill the program with control C it's not working the script is just printing haha you can't stop me this is a true virus all right copy the line that was printed to your terminal when trying to kill it and paste it into the field but do not submit yet all right um open a second terminal window okay and pipe the output of psox into grep malicious.
sh so psox let me just show you what it looks like by default so we get all this stuff like this is all the processes right so that's why we're going to want to use GP to find the one that we're looking for so we GP or pipe this into GP and we're going to GP for malicious Dosh and of course we don't need to pass in a file name because the thing we're grapping is the input that's being piped from PSX grap for that cool there are two things here in fact let me resize a little bit so you can see it become more
clear there we go um these two programs um like it says here you'll probably get two results one is for the malicious program itself um and one is for the grep command so we don't want the one that we used we don't want the GP one we want the actual command we ran so bash. m.sh is the one that we want not grep malicious.
sh okay once you have the PID process ID that would be this number right yeah yeah uh once you have the process ID um kill it so grab that kill wait is it this one wait it this one ah it is running right yeah there it is doing scary stuff what am I doing where is the pit what okay it's not that first one cuz it's changing but the second one's changing too what all right I'm confused for long
enough that we're definitely going to have to cut this out whoever's editing this what probably I'm stupid I'm grabbing this HP one oh my gosh all right cut back to this cut back to me being stupid ah I'm being dumb it's we want bash. m.sh that's the one that ran the program we don't want grep why am I grabbing the wrong one all right here we go um kill that one now if we come back over here it's dead wonderful once you've killed the program you should see your original terminal window that's
this one uh return to a new prompt and we did um because it stopped running the malicious program um and just for good measure let's do our PS Ox again we can see it's no longer there we still have the grep one that's because that's the that's the command we ran here but that's that's not the one all right cool with control of your terminal restored submit the message the malicious program PR in step two cool unix's philosophy all right Unix philosophy is pretty cool um it's been
around for a long time uh long time um and it's basically a simple set of principles that have guided the developments of Unix like operating systems like mac and Linux um and it can be summarized I'm I'm I'm paraphrasing a little bit to write programs that do one thing and do it well sorry I'm going to have to cut for a second here kick kick my daughter out it can be summarized paraphrased as write programs that do one thing and do it well so for example uh fully-fledged video games not really unix's philosophy
video games do all sorts of things they're full-blown applications they have goys they have interactions they have sounds all that kind of stuff um that doesn't mean that like games are bad but when we're talking about the Unix philosophy we're talking about writing small composable programs things like grep what does it do it searches text for substrings and it's very composable you can use it to search files you can also use uh standard out and piping to compose it with other programs that's kind of the whole thing
with Unix philosophy small simple programs um you want them to be able to work together using the text interface uh piping right input output streams um and the idea is that's a universal interface so the whole idea is we build all these different programs that use text and handle standard in and standard out and then we can pipe them all together to build really sophisticated automations this is why it Ops devops people Cloud Engineers they're able to get a lot done just with the command line because they can compose all these
interesting automations using pre-existing programs they don't always need to write custom software for everything they want to do cool all right um questions onto the questions which of the following does not follow the Unix philosophy cat grap LS worldof Warcraft exe that's the only one which is the more powerful interface at least from an extensibility and interoperability standpoint text or graphical it's going to be text top cool the top command is a very powerful tool it allows you to see which
programs are using the most res resources on your computer ah this was the lesson that activity monitor that's what activity monitor I never use it on Mac that's why I don't remember um but yeah task manager on Windows activity monitor on Mac OS they let you see all the programs that are running um you can kill them from that gooey window so looking at them and killing them that's what PS ox and kill are great for um top is similar but rather than using it to kill programs I typically use it to look
at res Source usage so um I want to see how much CPU what percentage of CPU programs are using um how much memory or Ram they're using that sort of thing so let's go ahead and run top like um less Nano whatever it is a an interactive CLI command so you'll notice my prompt is gone got to hit Q to get out of top um but it basically sits here and tells me you know what is running on my computer that's taking resources and I'm recording a video right now and so OBS studio is currently using 2.3 CPU cores and dwarfing uh the
resource usage of everything else so um this is pretty cool right just by running top you can kind of see hey what programs are hogging all of the resources on my machine um copy the column names from your terminal so the copy the column names are up here so you can see um we actually do get a PID here process ID in the top command so we could have found the PID for the kill command this way um I wouldn't probably have used top to do what we did in the last step because that scripts malicious. sh it wasn't
using very many resources it was just very slowly printing text to the terminal so it wouldn't have shown on top in the top command because it's not using a lot of CPU um and the top command kind of sorts by research usage by default uh so psox made a lot of sense um if you are trying to kill things that are using too many resources uh tops great and you can just grab the PID from here cool um so copy the column names got it and then exit top with q and paste it in good to [Music] go all right last chapter package
managers a pack package manager is just another piece of software that manages other pieces of software right so you've got all these programs on your computer um I we took a look at bin if I just LS bin see all this stuff in here um these tools well these tools it was a bad example they came they came bundled they came installed but other tools that you might want to install that don't come on your machine um are typically installed with a package manager on Linux well I should be specific on auntu
kind of the default package manager is apt so you ever pseudo app to get installed that's what uh Ubuntu uses and then on Mac there isn't an official package manager but kind of The Unofficial one that everyone seems to use is home brew so Brew install all right cool so let's install something using a package manager that's the assignment here neovim is a hyperextensible and newer version of Vim which is a new version of VI which is a popular text editor so we were using Nano earlier in this course it's good to
know about Nano just because Nano is like always there um basically any system you log into will have Nano available it's very very lightweight it's also not nearly as powerful as something like neovim neovim is a much newer much more powerful CLI text editor so let's go ahead and install it we are not on WSL auntu so if you're on WSL auntu you can install follow these instructions we are going to follow the Mac instructions we going to brew install uh Neo which I actually think I might already have neovim about to find
out so this is going to go ahead and install Okay looks like the installation finished now we're going to test that oops clear uh by running envm neovim D- version and we got version 0103 perfect we'll paste that output into a text box very good all right using neovim this isn't a course on neovim um we'd need a lot more time for that but but I'm at least going to show you how to enter and exit neovim because it's likely that you'll find yourself in Vim at some point and wondering how to
get out so let's go ahead and use neovim to open up uh World Bank public company info so do do SL do where are we World M so envm public company info all right now we're in neovim we're looking at the contents of that file um it's text file that uses markdown syntax great you can open a file we already did that that once it's open we notice that we can't type anything this is very important if I type J K what it's like moving me around this is why people get really confused in typing letters but
they're not typing my cursor is just moving in order to type we actually have to exit the mode that we're currently in which is called normal mode and go into insert mode we do that by pressing the I key so let's do that and now here at the bottom we can see insert that means we're in insert mode so now if I type I'm editing the file all right you should now be able to delete the password so let me go back into normal mode and move over to where am I am I deleting some password oh I'm just deleting the whole
password okay so I'm going to go into insert mode delete the password type in redacted now we're going to exit normal mode with the Escape key you can tell because now we've got the full character highlight instead of the flashing bar back in normal mode in normal mode we can use the colon W command so if you look down here at the bottom you'll see I type colon then I type w hit enter that saves my changes and then colon Q so earlier in the course you'll remember me saying that just pressing Q doesn't exit neovim that
is true because you need to type colon Q while in normal mode all right that gets us out of neovim we've escaped neovim it's a huge badge of honor use cat to view the contents of the edited file public company info you can see it's now changed great let's paste that edited file in here all right package manager review so apt and Brew are not the only package managers out there I don't want you to get that impression they are just some of the more popular ones um especially for auntu and Mac
when you type a command like app install neovim on iunu the package manager does a few things first checks to see if the package is already installed if it's not installed it goes and downloads the package from the repository so app has its own repositories of kind of the published versions of these uh softwares and it will go download that uh if it doesn't have it um then it will install it on your computer which basically means it puts the program somewhere on your file system it will also install any
dependencies that that program needs in order to function this is like the really hard thing that package managers do it's not trivial to figure out all those dependency trees and make sure that they're all up to dat and working and then it will also hopefully automatically add that program that binary if it is a binary it might be an interpreted program whatever to your path if it should be there that way you don't need to go manually muck with your path and again this is important to understand usually a brew install or an
app install we'll just add an installed command like neovim right NVM was added to our path so we can use it from anywhere can I exit neim there we go but if it didn't we need to go find it and add it to our path so if we want to see where it is I can do which neovim you can see opu bin neovim so opu bin this is of course in my path and Brew put it there for me I believe cool what do you know it's going to ask us to do which enm question what do package managers like AP and Brew not do um manage the installation of
software and dependencies they do that download soft from the internet they do that debug code and fix bugs in the software manages no they're not debuggers Webby there's one more package manager um it's actually more of an anti- package manager that I want to show you um I think it's a really cool project Webby lets you install command line tools directly from the web uh with no need for a local command line tool like apt or Brew so apt and Brew are very kind of sophisticated uh they've
been around for a long time um but the point is you need apt or you need Brew on your system when you buy a new Macbook it doesn't come with Brew you have to go download install Brew itself um and then you use Brew to manage a lot of your tools the really cool thing about Webby in my opinion is that it has no it has no package manager it's basically a web server that serves up inst the official installation scripts for various popular tools it allows you to install tools via their official installation instructions but like all
from one interface so let's go ahead and use it see how it works um we're going to install LSD which is a more modern version of the ls command written in Rust I believe so first we're going to go to Webby and let me zoom in here and we're going to go find the LSD LSD program search for it there it is LS Deluxe cool and then we're just going to install it using installation instruction so this is basically how weby works it's pretty awesome select your operating system usually it's the
same command but of course Windows has to be special we going to grab this now keep in mind I haven't installed web on my machine I'm just grabbing this curl command and running in my terminal we're going to talk about the security implications of that in just a second but for now I'm just going to do it run that and it installed LSD it shows me where it put it it put it in my home directory under local bin LSD and I believe it has added it to my path automatically does it say that well let's find out LSD I've got it
okay cool we're good to go so did it automatically if it didn't do it we'd have to add um of course local bin to my path okay back to the lesson try running LSD with the-- tree flag uh clear LSD D- tree oops LSD I'm not LDS anymore got to spell that right cool that's awesome I love that builds out that whole file tree for us cool um run it again with both the tree and classic flags all right that gets rid of color it looks like cool U paste the output into the field oh I need to do the right place
World Bank private transactions all right so LSD we want private transactions D- classic-- tree very good grab that one pop that bad boy in now before we move on I want like I said I want to talk about security for just a second so one of the guys one of the maintainers of Webby his name is AJ he's awesome he actually came on the backend banter podcast to talk about Webby a lot of people very reasonably so get nervous when you have to paste a command like this like this one into your terminal and run it so why why are they nervous
what is this well this is a curl command that basically says hey go to this remote server webb. sh download the script and immediately pipe it in see we're piping the script itself that we're downloading into my shell interpreter in other words download this thing from the remote host and execute it immediately right that's basically what this is that's exactly what this is doing there's some security concerns there right what if this web server gives me a malicious script right what if it's a malicious script that screws
up my machine or looks for credit card numbers or anything like that right so the typical advice of course is well you should download the script first look at it inspect it make sure it's safe and only then run it um you should only use so that's assuming you're able to look through the script yourself in the case of like actual programs you typically want it signed by the publisher of the script to make sure that it hasn't been tampered with or changed okay all that to say if you're really
curious about AJ's argument for why this isn't really a concern I would definitely recommend checking out the podcast because he'll do a much better job of explaining it than I will here but I will give you the gist so the first thing is we're using https which guarantees a couple things first of all it guarantees because this is just how https works that the script we getting was actually securely signed via https that cryptography by the owner of the webb.
AG domain name so do we have to trust Webbie yes when we run this we are putting our full faith and trust in Webby to not screw us over so yes if Webby got hacked someone could change the server to serve up Melissa scripts that is that is a security risk and it's important to understand that if you are nervous about that of course you could always just curl the script first then read it then execute it there's no reason you can't do that but it is important to understand you have to trust the source but because we are using https here we're really not
concerned about a man in the middle attack right someone getting in between us and the Webby server and altering the script just because that's the whole point of https right HTTP script's guaranteed to show up in order so we can execute it htps it's guaranteed to be coming from Webby it's been cryptographically signed it's about as good as it gets so are the potential security concerns with Webby I think I think they are but I do I am on AJ side after the conversation we had in the sense that I do think they're minimal um
and I think that uh I mean there's a risk to everything you do online so anyways you know use it at your own risk I suppose um I do think it's a really cool tool and just to be aware of that it's there and like I said go listen to that podcast if you're interested cool done with Webby vs code vs code now up to this point boot Dev you've written code if you've been following Along on boot Dev so if you've done our python course and now our Linux course um um you've probably written all your python
code in the browser in boot devs in browser editor um and then now we've been using a standalone terminal to do this course um some developers do their work inside a terminal using a terminal editor like neovim I actually don't I'm not that cool so a lot of us that uh I can say we're not cool because I'm in this group but a lot of us do use a hybrid kind of gooey SL terminal experience I used to use VSS code it was my daily driver for many years I have recently just in the last year switched
over to another editor called Zed that I really like big downside to zed at the moment is it doesn't work well with uh well it doesn't work at all on Windows and so if you're doing like a Windows WSL thing that does not have a good experience or I don't even think it works at all whereas Visual Studio code is built out of the box to work with WSL which is pretty awesome um so if you're on WSL um and you're new to this to all this stuff like VSS code genuinely is a really good option if you are interested
in getting really good at Vim which is like a whole skill set in of itself like then definitely check out Neo or vim and you'll also hear emac thrown around I I have nothing to say about evx so if you don't have a preferred editor yet I would just recommend installing VSS code if you're on Windows and honestly checking out Zed if you're on if you're on Mac or a straight Linux installation and with that I hope you've enjoyed this course I hope you've gotten a little bit out of it like I said this
is not a course on the entire of Linux as an operating system as a kernel I should say this is a course on how to get up and running with a Unix like command line and most people associate that with Linux a lot of people develop on Mac or on Windows and deploy to Linux servers so it's really really good to know how to SSH into a server which basically means connect to a server via terminal and muck around with it use it run programs see what's going on look at logs all that kind of stuff is what we learned in this course you'll use it not
just for Server management you'll use it on your local machine as you're installing tools doing local development work thanks so much for staying with me this long
```

**Linux không chỉ là thứ để khoe khoang với bạn tình tiềm năng**

Kỹ năng Linux, và rộng hơn là khả năng sử dụng dòng lệnh, shell, terminal, sẽ cực kỳ hữu ích trong bất kỳ công việc kỹ sư phần mềm nào, thậm chí cả trong các công việc DevOps, IT hay tự động hóa. Nếu bạn làm việc gần với internet, hiểu biết về Linux sẽ là một công cụ vô giá trong bộ kỹ năng của bạn. Trong video này, tôi sẽ hướng dẫn bạn toàn bộ khóa học nhập môn Linux trên Boot.dev, nhưng trước tiên, tôi muốn giải thích rõ ràng khóa học này là gì và không phải là gì.

Tôi gọi khóa học này là "Học Linux" vì đó là điều mà hầu hết mọi người nghĩ đến khi họ liên tưởng đến terminal. Khi họ nghĩ về `ls`, `cd`, `grep`, `find`, họ nghĩ về Linux. Nhưng thực ra, tên của khóa học hơi sai lệch. Nó nên được gọi là "Học cách sử dụng shell và terminal trong môi trường giống Unix". Đây là một hệ thống Unix, tôi biết điều đó, vì vậy chúng ta sẽ tập trung vào shell và terminal trong khóa học này. Bạn có thể sử dụng Linux hoặc Mac, cả hai đều là hệ thống giống Unix. Việc điều hướng dòng lệnh trên các hệ điều hành này khá giống nhau. Nếu bạn đang sử dụng Windows, đừng lo, chúng tôi sẽ thiết lập cho bạn một môi trường WSL (Windows Subsystem for Linux) để bạn có thể theo dõi trong Ubuntu.

Các chương trong khóa học này bao gồm:

1. Terminal và shell
2. Hệ thống tệp
3. Quyền
4. Chương trình
5. Đầu vào và đầu ra
6. Trình quản lý gói

Mục tiêu của khóa học là khi bạn hoàn thành, bạn sẽ cảm thấy rất thoải mái khi sử dụng terminal để làm việc hàng ngày, cả trên Linux và Mac. Nếu bạn làm việc với các máy chủ từ xa, ví dụ như máy chủ web Linux từ xa, bạn sẽ cảm thấy thoải mái khi điều hướng hệ thống tệp trên loại máy chủ đó.

Tuy nhiên, đây không phải là khóa học về kernel Linux, hệ điều hành, hay quản trị máy chủ. Khóa học này thực sự là điều kiện tiên quyết cho các loại khóa học đó. Khóa học Linux này là khóa học số 2 trong lộ trình nhà phát triển backend trên Boot.dev, và lý do là vì tất cả các kỹ năng shell và terminal mà bạn sẽ học trong khóa học này là thứ mà không chỉ mọi nhà phát triển backend nên có, mà tôi thực sự tin rằng mọi nhà phát triển nói chung nên hiểu cách điều hướng dòng lệnh.

Nhân tiện, để bạn biết ai là người đang dạy bạn, tôi là Lane, người tạo ra Boot.dev, một nền tảng tương tác cho giáo dục kỹ thuật phần mềm. Tôi đã viết code khoảng 15 năm và chuyên nghiệp khoảng 8 năm. Tôi chủ yếu chuyên về backend và kỹ thuật dữ liệu, nhưng giống như hầu hết các nhà phát triển, tôi đã "chấm phá" khắp các lớp trong stack.

Bây giờ, hãy nói về cách bạn sẽ hoàn thành khóa học này. Cách thứ nhất là bạn có thể lấy một túi bỏng ngô, ngồi xuống và xem tôi làm tất cả công việc cho bạn. Bạn có thể giả vờ rằng bạn đang học khi tôi gõ mọi thứ. Đó không phải là một lựa chọn tốt. Nếu bạn xem toàn bộ khóa học này mà không tạm dừng, bạn đã làm sai. Vì vậy, hãy đảm bảo rằng bạn đang ở trước máy tính, có quyền truy cập vào terminal và thực sự làm theo khi chúng ta đi qua toàn bộ khóa học này.

Nội dung của khóa học này, giống như tất cả các khóa học trên Boot.dev, hoàn toàn miễn phí. Tôi rất khuyến khích bạn truy cập Boot.dev, tạo một tài khoản miễn phí và làm theo các hướng dẫn văn bản khi bạn xem video này. Điều khiến mô hình nội dung miễn phí này hoạt động là tất cả các tính năng tương tác trên Boot.dev, sau một thời điểm nhất định, đều là trả phí. Vì vậy, nếu bạn thích các tính năng gamification, xem giải pháp, trợ lý AI, chứng chỉ, tất cả những thứ đó có sẵn với tư cách thành viên trả phí. Nhưng bạn không cần phải trả phí để tham gia khóa học này. Tuy nhiên, nếu bạn muốn trở thành thành viên, tôi có mã giảm giá cho bạn. Bạn có thể sử dụng mã `BOOTS` để được giảm 25% trong năm đầu tiên nếu bạn chọn gói hàng năm.

Đủ về việc quảng cáo, hãy nói về điều gì sẽ xảy ra nếu bạn bị kẹt trong khóa học này. Làm ơn đừng yêu cầu giúp đỡ trong phần bình luận YouTube. Tôi không thể giúp bạn một cách hợp lý ở đó. Hãy tham gia Discord của Boot.dev, hoàn toàn miễn phí để tham gia. Hãy thoải mái đặt câu hỏi ở đó.

Bây giờ, hãy nói về shells, terminals và Linux. Tôi đang ở trong khóa học "Học Linux", "Học Shell và Terminal" trên Boot.dev, và hãy bắt đầu. Để giúp bạn hình dung, tôi có terminal emulator của mình ở bên phải, đây là Ghostty, và tôi có hướng dẫn bài học ở bên trái màn hình. Trong bài học đầu tiên này, tôi sẽ bỏ qua phần đầu vì chúng ta đã đề cập đến nó trong phần giới thiệu của video này. Vì vậy, hãy đi thẳng vào bài tập.

**Bài tập:** Tìm và mở một terminal trên máy tính của bạn. Tôi đã mở Ghostty. Tôi đang sử dụng MacOS. Nếu bạn đang sử dụng Mac, bạn có thể sử dụng Ghostty hoặc terminal tích hợp sẵn. Nếu bạn đang sử dụng Windows, bạn có thể mở Command Prompt. Nếu bạn đang sử dụng Linux, hy vọng bạn biết terminal của mình ở đâu. Chúng ta sẽ sao chép lệnh này và dán vào terminal của mình và chạy nó: `echo Hello World`. Nó sẽ in ra "Hello World" vào console. Sau khi làm xong, hãy trả lời câu hỏi: "Điều gì xảy ra khi bạn nhấn Enter?" Văn bản "Hello World" được in ra terminal console. Khá đơn giản. Nếu bạn đến từ thế giới Python, điều này rất giống với `print("Hello World")` hoặc trong Go, `fmt.Println("Hello World")`. Đây là tương đương của terminal hoặc shell với `print("Hello World")`.

Các từ như terminal, shell, command line, CLI và command prompt thường được các lập trình viên sử dụng một cách thiếu chính xác. Mặc dù các định nghĩa chính xác có thể hơi khác nhau, nhưng chúng ta thường đang nói về một chương trình cho phép bạn tương tác với máy tính của mình thông qua văn bản. Nếu bạn mới làm quen với dòng lệnh, bạn có thể đã quen với GUI (Giao diện người dùng đồ họa). GUI là một giao diện trực quan phức tạp cho phép bạn thực hiện các tác vụ trên máy tính của mình. Hãy nghĩ đến desktop Windows, nó có các menu để lướt qua, các biểu tượng để nhấp vào và thậm chí là các hệ thống quản lý cửa sổ phức tạp. CLI (Command Line Interface) là một giải pháp thay thế đơn giản hơn nhiều. Thay vì sử dụng các nút và menu phức tạp, bạn tương tác hoàn toàn thông qua văn bản. Bạn muốn chạy một chương trình? Đừng nhấp vào biểu tượng, chỉ cần gõ tên chương trình. Bạn muốn xem một tệp? Đừng mở Microsoft Word, chỉ cần gõ một lệnh.

Mặc dù GUI có rào cản thấp hơn để sử dụng (chúng thường dễ hiểu và tự giải thích), chúng cũng khá hạn chế. Một giao diện dòng lệnh mạnh mẽ hơn vì bạn không bị giới hạn bởi các nút và widget được cung cấp bởi các nhà phát triển ứng dụng. Thay vào đó, bạn có quyền truy cập trực tiếp vào các cấp độ thấp hơn của hệ thống của mình. Là một lập trình viên, đây là điều không thể thương lượng. Bạn cần phải thoải mái khi sử dụng dòng lệnh.

**Tiếp theo: Command Line vs GUI (Giao diện người dùng đồ họa)**

Trong tất cả các khóa học khác trên Boot.dev, hoặc ít nhất là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình. Và khi bạn muốn chạy code của mình, bạn sẽ nhấp vào nút "Run". Tuy nhiên, thông thường, là một nhà phát triển thực thụ (và điều này không hoàn toàn đúng, nó hơi thiên về kinh nghiệm của tôi với tư cách là một nhà phát triển web), nhưng thường xuyên, bạn sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ. Có những IDE ngoài kia nơi bạn nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn những người trong chúng ta sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất tốt vì bạn sẽ sử dụng nó. Ví dụ, khi tôi viết code Python, tôi thường chạy code của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình chỉnh sửa của tôi. Đó chỉ là cách tôi thích thiết lập môi trường phát triển của mình.

Vậy, CLI là gì? Nó là viết tắt của Command Line Interface, nhưng nó là một giao diện văn bản để tương tác với các ứng dụng và chương trình. Nếu bạn không đến từ nền tảng phát triển, bạn có thể quen với việc tương tác với máy tính của mình thông qua giao diện người dùng đồ họa. Bạn nhấp vào các biểu tượng khác nhau, bạn điều hướng cấu trúc thư mục bằng cách sử dụng thứ gì đó như Windows Explorer hoặc Finder trên Mac, và bạn sử dụng chuột rất nhiều. Bạn đang nhìn vào hình ảnh, bạn đang nhấp vào các thứ. Đó là giao diện người dùng đồ họa. Một giao diện dòng lệnh chỉ có văn bản, nghĩa là nó sẽ khó học hơn vì bạn phải học tất cả các lệnh khác nhau. Nhưng một khi bạn biết các lệnh, nó thực sự nhanh hơn rất nhiều để sử dụng giao diện dòng lệnh vì nó chỉ là văn bản và bạn có thể đi nhanh như bạn có thể gõ. Nó cũng làm cho việc tự động hóa mọi thứ trở nên dễ dàng hơn nhiều vì viết một chương trình hoạt động với văn bản dễ dàng hơn nhiều so với viết một chương trình cố giả lập các cú nhấp chuột và những thứ tương tự.

**Bài tập:** Trong terminal của bạn, chạy lệnh sau: `whoami`. Tôi được kết quả là "wags_lane". Đó là tài khoản người dùng đăng nhập của tôi trên Mac. Khi chúng ta hoàn thành, hãy trả lời câu hỏi: "Điều gì xảy ra khi bạn chạy lệnh?" Tên người dùng của tôi được in ra console.

**Bài học tiếp theo:** Cài đặt Windows Subsystem for Linux (WSL). Tôi sẽ bỏ qua phần này vì tôi không sử dụng Windows. Nếu bạn đang sử dụng Windows, bạn sẽ không thể sử dụng Command Prompt mặc định cho phần còn lại của khóa học. Bạn sẽ sử dụng Linux chạy trên máy Windows của mình với WSL. Nếu bạn đang sử dụng Windows và cần thiết lập WSL, hãy đến bài học này, đó là bài học số 3 trong chương 1. Tất cả các hướng dẫn đều ở đây. Điều này đã được kiểm tra kỹ lưỡng. Chúng tôi đã có hàng ngàn sinh viên cài đặt và sử dụng WSL. Đừng lo, nó sẽ không làm hỏng cài đặt Windows của bạn. Đây không phải là tình huống dual boot nơi bạn phải phân vùng ổ đĩa. Không có gì điên rồ như vậy. Nó thực sự khá đơn giản để thiết lập. Đó là lý do tại sao chúng tôi khuyên dùng nó. Vì vậy, nếu bạn đang sử dụng Windows và cần thiết lập WSL, hãy làm điều đó. Khi bạn hoàn thành, bạn sẽ có một terminal Linux, một shell Linux mà bạn có thể sử dụng. Nó sẽ là bash, và bạn sẽ có thể theo dõi phần còn lại của khóa học. Trong phần còn lại của khóa học, mọi thứ chúng ta làm sẽ hoạt động với bash và zsh, hai shell trên Linux và Mac, và sẽ không cần nhiều tùy chỉnh. Cả Linux và Mac đều là hệ thống giống Unix, và tất cả những gì chúng ta sẽ đề cập ở đây đủ giống nhau để hoạt động. Vì vậy, chúng ta sẽ bỏ qua phần đó.

**Tiếp theo: Terminal là gì?**

Là các nhà phát triển, đôi khi chúng ta sử dụng tất cả các thuật ngữ này thay thế cho nhau. Các thuật ngữ đó là gì? Terminal, shell, command line interface (CLI). Bạn thường nghe các nhà phát triển sử dụng các từ khác nhau để chỉ cùng một thứ, về cơ bản có nghĩa là tôi đang nhập văn bản vào terminal của mình. Vì vậy, chỉ cần hiểu rằng chúng ta thường có nghĩa giống nhau và chúng ta hơi lỏng lẻo với từ ngữ. Nhưng chúng thực sự có các định nghĩa khác nhau. Một terminal, để thực sự chính xác, thực sự không tồn tại trên máy tính của bạn. Một terminal là một thiết bị vật lý, như hình ảnh lớn này ở đây. Ngày xưa, bạn phải có một terminal. Bạn có thể nghĩ nó giống như một combo màn hình và bàn phím. Nó là thứ cho phép bạn tương tác với phần mềm. Đó là một terminal vật lý. Ngày nay, chúng ta không sử dụng những thứ đó thường xuyên. Chúng ta sử dụng terminal emulator. Đó là những gì Ghostty là. Đó là một chương trình trên máy tính của tôi mô phỏng một terminal. Nó cho phép tôi nhập văn bản và hiển thị văn bản trở lại tôi. Vì vậy, để thực sự chính xác, một terminal chỉ là nơi bạn có thể nhập văn bản và nơi có thể hiển thị văn bản trở lại.

**Câu hỏi:** Một terminal hoặc terminal emulator là gì?

- Một hệ điều hành dựa trên văn bản
- Một tập hợp các lệnh có thể được sử dụng để điều khiển máy tính
- Một chương trình chấp nhận các lệnh dựa trên văn bản và có thể hiển thị văn bản trên màn hình
- Một Raspberry Pi mới ra lò

Đáp án: Một chương trình chấp nhận các lệnh dựa trên văn bản và có thể hiển thị văn bản trên màn hình.

Vì vậy, nếu đó là terminal, thì tôi không muốn xúc phạm bất kỳ ai làm việc trên terminal, nhưng khi so sánh với shell, terminal có thể được coi là khá "ngu ngốc". Nó không thực sự phải diễn giải các lệnh. Tất cả những gì nó phải làm là chấp nhận văn bản và hiển thị văn bản. Vì vậy, shell là chương trình thực sự cung cấp khả năng tương tác trong terminal. Nó chờ đợi lời nhắc, xử lý lời nhắc, diễn giải lời nhắc, thực thi lời nhắc và sau đó cung cấp cho bạn một lời nhắc mới khi nó hoàn thành xử lý lời nhắc cũ. Từ viết tắt cho điều này là REPL (Read-Evaluate-Print Loop). Vì vậy, khi chúng ta gõ một lệnh như `echo Hello World`, khi tôi nhấn Enter, điều đầu tiên shell làm là đọc `echo Hello World`. Nó đánh giá nó: "Tôi nên làm gì với lời nhắc này?" Nó in ra phản hồi, trong trường hợp này là "Hello World", và sau đó nó lặp lại và cung cấp cho tôi một lời nhắc mới, đó là lý do tại sao tôi có thể làm lại.

**Bài tập:** Trong shell của bạn, chạy lệnh sau: `expr 123456 + 7890`. Dán kết quả của lệnh đó vào hộp văn bản. Hãy chạy lệnh: `expr 123456 + 7890`. Kết quả là `131346`. Chúng ta sẽ dán nó vào hộp văn bản và gửi đi. Điều này chỉ để cho thấy một ví dụ khác về lời nhắc mà shell của chúng ta có thể đánh giá. Trong trường hợp này, chúng ta đang nói `expr 123456 + 7890`. Nó thực sự thực hiện phép cộng đó. Các shell như bash hoặc trong trường hợp của tôi là zsh, chúng là các ngôn ngữ lập trình tinh vi và chúng có thể làm rất nhiều thứ. Vì vậy, không chỉ là chúng có thể in ra `Hello World` cho bạn, chúng cũng có thể làm toán.

Như chúng ta đã nói trong bài học trước, các shell như zsh và bash là REPL, nhưng chúng cũng là các ngôn ngữ lập trình hoàn chỉnh. Chúng được xây dựng để là các ngôn ngữ kịch bản khá đơn giản. Vì vậy, chúng không phải lúc nào cũng tốt nhất để xây dựng các ứng dụng web lớn (shout-out Sarah và bash stack, làm cho nó có thể, mặc dù có thể không được khuyến nghị). Nhưng điểm là bạn có thể làm những điều rất tinh vi trong bash và zsh, và nói chung là shell scripting.

Và giống như hầu hết các ngôn ngữ lập trình, bạn có thể sử dụng và tạo các biến trong bash và zsh. Tạo một biến rất đơn giản. Ví dụ, ở đây tôi có thể tạo biến `name` và đặt nó bằng tên của tôi, Lane. Nếu tôi muốn sử dụng biến này, đây là nơi nó trở nên hơi khác so với một ngôn ngữ như Python. Thay vì chỉ sử dụng lại tên biến `name`, tôi thực sự phải thêm tiền tố nó với dấu đô la. Vì vậy, bất cứ khi nào bạn đặt một biến, bạn không cần dấu đô la, nhưng khi bạn sử dụng nó, bạn cần nó. Chúng ta có thể in nó ra bằng `echo $name`. Bạn có thể thấy nó đã chèn chuỗi `Lane` vào biến `name`.

**Bài tập:** Trong phần còn lại của khóa học này, bạn sẽ là một nhà phát triển pháp y được thuê bởi Ngân hàng Thế giới hư cấu để điều tra một vi phạm bảo mật. Và giống như hầu hết các tập đoàn lớn, họ không biết họ đang làm gì, nhưng họ rất vui khi trả quá nhiều tiền để bạn đến và nói rằng một bên thứ ba đã xem xét hệ thống của họ. Hóa ra, bạn chưa phải là chuyên gia, chúng ta sẽ học trong khóa học này, nhưng bạn rất vui khi học hỏi trên tiền của người khác. Vì vậy, tại sao không nhảy ngay vào nó? Bạn sẽ sử dụng terminal và shell của mình để điều hướng tệp, thao tác văn bản, chạy các chương trình. Đây là tất cả những thứ chúng ta sẽ học trong suốt khóa học, nhưng chúng ta sẽ làm điều đó trong bối cảnh câu chuyện của tập đoàn lớn Ngân hàng Thế giới này. Chúng ta sẽ là một nhà phát triển pháp y, xem xét qua các tệp, `grep` qua các thứ, tìm kiếm các thứ, in chúng ra và thực hiện phân tích chung về văn bản như một cách thực tế để học cách điều hướng một hệ thống giống Unix.

Và tôi không đề cập sâu về điều này, nhưng như tên của khóa học là "Học Linux", nhiều bạn sẽ sử dụng Linux, nhưng Mac, từ góc độ dựa trên văn bản, trên dòng lệnh, rất giống với Linux. Chúng ta gọi nó là giống Unix. Vì vậy, tất cả những thứ này hoạt động ngay lập tức. Quản trị máy chủ là một câu chuyện khác. Nó không giống như một máy chủ Linux và một máy chủ Mac hoạt động giống nhau. Và cũng không giống như phát triển cục bộ. Nhưng điểm là phát triển cục bộ và điều hướng shell và terminal trên Mac rất giống với Linux, trong khi Windows thì không. Đó là lý do tại sao nếu bạn đang sử dụng Windows, chúng tôi yêu cầu bạn sử dụng một máy ảo Linux cụ thể, cụ thể là WSL.

**Bài tập đầu tiên:** Đặt ba biến sau trong shell của bạn. Đầu tiên, chúng ta sẽ đặt `bank_name` bằng "World Bank", `founded` bằng 1969 và `ceo` là Jeff Gates nổi tiếng. Tiếp theo, chúng ta sẽ viết và thực thi một lệnh sẽ in ra dòng sau bằng cách sử dụng `echo` và các biến động mà chúng ta vừa đặt. Vì vậy, chúng ta sẽ `echo` chuỗi "Ngân hàng $bank_name được thành lập vào năm $founded bởi $ceo". Chạy nó và xem nó có hoạt động không: "Ngân hàng World Bank được thành lập vào năm 1969 bởi Jeff Gates". Hoàn hảo. Dán toàn bộ lệnh đã tạo ra đầu ra chính xác vào trường văn bản. Chúng ta sẽ làm điều đó và chúng ta đã xong.

**Lịch sử:** Khi bạn làm việc trong một REPL, thật hữu ích khi xem các lệnh bạn đã gõ trước đây. Bây giờ, để công bằng, như chúng ta đang nhìn vào terminal của tôi, chúng ta có thể thấy mọi thứ chúng ta đã gõ trước đây, nhưng thực sự có một lệnh giúp dễ dàng xem mọi thứ chúng ta đã gõ trước đây. Nó giữ một bản ghi và đó là lệnh `history`. Nó trông như thế này: `history`. Và bạn có thể thấy ở đây là 15 lệnh cuối cùng tôi đã chạy. Vì vậy, trong shell của bạn, đặt hai biến: `department` thành "engineering" và `team` thành "Ops". Sử dụng `echo` để in ra thông điệp sau: "I work in $department on $team". Chạy lệnh `history` và dán đầu ra của nó vào trường văn bản. Bây giờ, chúng ta sẽ làm điều đó và chúng ta đã xong.

Bây giờ, như bạn có thể thấy, terminal của tôi đang trở nên hơi chật chội. Tôi đang ở dưới cùng màn hình, vì vậy tôi sẽ làm điều mà khóa học sẽ đề cập sau, nhưng tôi sẽ làm ngay bây giờ. Tôi sẽ gõ `clear`. Nó chỉ dọn sạch terminal. Nó không xóa lịch sử của tôi, nhưng nó cho tôi một cửa sổ sạch sẽ để làm việc.

**Tiếp theo:** Bạn thường muốn chạy lại một lệnh. Bạn có thể gõ lại, nhưng giả sử bạn không có tốc độ gõ nhanh như Prime, điều đó có thể là một cơn ác mộng. Và tôi không có. Tốc độ gõ của tôi chỉ khoảng 80 từ mỗi phút, thậm chí tệ hơn khi tôi đang quay phim. Vì vậy, thay vì gõ lại `history`, tôi có thể chỉ cần nhấn phím mũi tên lên và xem lệnh cuối cùng của tôi. Tôi cũng có thể tiếp tục nhấn mũi tên lên và bạn sẽ thấy nó đang lướt qua tất cả những thứ chúng ta đã chạy trong quá khứ. Và phím mũi tên xuống sẽ đi về phía trước trong thời gian. Ví dụ, nếu tôi gõ `echo 1`, `echo 2`, `echo 3`, nhấn mũi tên lên một lần, nó sẽ đến `echo 3`. Nhấn mũi tên lên lần nữa, nó sẽ đến `echo 2`, và một lần nữa, nó sẽ đến `echo 1`. Và tôi có thể đi xuống lại `2`, xuống `3`, và xuống một lời nhắc trống.

**Câu hỏi:** Phím mũi tên nào đi ngược lại lịch sử của bạn và phím mũi tên nào đi về phía trước? Mũi tên lên đi ngược lại và mũi tên xuống đi về phía trước.

**Câu hỏi khác:** Lệnh `clear` làm gì?

- Mở một cửa sổ terminal mới
- Xóa lịch sử shell của bạn khỏi bộ nhớ
- Xóa màn hình terminal

Đáp án: Nó chỉ xóa màn hình.

**Các lựa chọn thay thế terminal:** Như tôi đã nói, tôi đang sử dụng Ghostty. Đó là một terminal emulator mới được tạo bởi Mitchell Hashimoto, người sáng lập HashiCorp. Nó khá tuyệt vời. Đây là một terminal emulator mới hoàn toàn. Ngoài Ghostty, tôi biết nhiều người sử dụng Alacritty. Tôi nghĩ đó là terminal emulator phổ biến nhất hiện nay. Trình chỉnh sửa văn bản hàng ngày của tôi là Zed, thực sự sử dụng Alacritty dưới hood. Tôi khá chắc chắn, nhưng tôi chủ yếu sử dụng terminal tích hợp. Cũng có các terminal tích hợp được xây dựng trong các trình chỉnh sửa như VS Code và Cursor. Hầu như mọi trình chỉnh sửa hoặc IDE đều có terminal tích hợp, nhưng nhiều người không sử dụng terminal tích hợp. Và nếu bạn sử dụng thứ gì đó giống như Vim, bạn có nhiều khả năng sử dụng thứ gì đó như Ghostty như một terminal emulator toàn màn hình vì trình chỉnh sửa văn bản của bạn, Vim hoặc NeoVim, chạy trong terminal. Vì vậy, tất cả những điều này để nói, hãy chọn terminal emulator bạn muốn sử dụng cho khóa học này. Nó không quan trọng. Bạn có thể chỉ sử dụng terminal mặc định nếu bạn muốn. Kiểm tra bài học này và kiểm tra các terminal emulator khác nếu bạn tò mò.

**Câu hỏi:** Cái nào không phải là terminal emulator?

- Windows Terminal
- Alacritty
- Ghostty
- Ubuntu

Đáp án: Ubuntu là một hệ điều hành, không phải là terminal emulator.

**Tiếp theo: Chương 2 - Hệ thống tệp**

Bạn có lẽ đã quen thuộc với ý tưởng về hệ thống tệp nếu bạn đã sử dụng máy tính trong phần lớn cuộc đời của mình. Ý tưởng về các thư mục, hoặc các thư mục như chúng được gọi trong các hệ thống giống Unix, lồng vào nhau trong một hệ thống phân cấp có lẽ đã rất quen thuộc. Vì vậy, về bản chất, đó là những gì hệ thống tệp là. Đó là một cây thư mục bắt đầu từ một thư mục gốc, chứa các thư mục khác và chúng có thể đi sâu bao nhiêu tùy bạn. Điều đó không hoàn toàn đúng. Chúng ta không có không gian vô hạn trên máy tính, nhưng bạn biết đấy, chúng có thể đi khá sâu. Và các thư mục chỉ chứa các thư mục khác và các tệp khác.

Vì vậy, các thư mục chỉ là các thùng chứa giữ các tệp và sau đó các tệp, tất nhiên, thực sự chỉ là các khối nhị phân vào cuối ngày với một số siêu dữ liệu đính kèm để cho bạn biết những gì trong khối nhị phân đó. Một tệp có thể lưu trữ bất cứ thứ gì. Nó có thể là một hình ảnh, tệp văn bản, PDF, code. Nó thực sự có thể là bất cứ thứ gì. Và tùy thuộc vào người đọc tệp đó để diễn giải dữ liệu đó và sử dụng nó như dự định.

Vì vậy, khi bạn mở terminal của mình, thư mục làm việc, hoặc thư mục bạn đang ở, sẽ ở đâu đó. Rất có thể, nó sẽ ở trong thư mục chính của bạn. Ví dụ, nếu tôi chạy lệnh `pwd`, nó cho tôi biết tôi đang ở trong `/users/sl/wags_lane`. Vì vậy, dấu gạch chéo `/` đại diện cho thư mục gốc. Nếu tôi cuộn lên đây, bạn có thể thấy thư mục đầu tiên này chỉ là `/`. `users` sau đó là một thư mục khác xuống. Nếu tôi liệt kê thư mục gốc, bạn có thể thấy tôi có tất cả các thư mục khác trong thư mục gốc của mình, nhưng chúng ta đặc biệt đang ở trong `users`. Và sau đó trong `users`, chúng ta đang ở trong tên người dùng của tôi cụ thể. Vì vậy, `/users/sl/wags_lane`.

**Bài tập:** Bạn đã đăng nhập từ xa vào máy của một nhân viên đáng ngờ tại Ngân hàng Thế giới. Đầu tiên, bạn cần xác định bạn đang ở đâu trên hệ thống tệp của họ. Vì vậy, chúng ta gõ `pwd`. Dán toàn bộ đầu ra của lệnh vào trường văn bản và gửi nó. Vì vậy, chúng ta sẽ chỉ lấy lại `/users/sl/wags_lane`. `pwd` là print working directory, cho chúng ta biết chúng ta đang ở đâu. Dán nó vào và chúng ta đã xong.

Khi bạn làm việc với dòng lệnh, đường dẫn tệp là xương sống của việc điều hướng. Bạn có thể đã quen với việc nghĩ về các tệp và thư mục như các cấu trúc cây lồng vào nhau. Rốt cuộc, đó là những gì chúng là. Và đó là cách Windows Explorer hoặc Finder trên Mac hiển thị chúng. Một đường dẫn tệp chỉ là một biểu diễn dựa trên văn bản của một tệp hoặc thư mục trong hệ thống phân cấp. Tất cả các đường dẫn tệp tuyệt đối bắt đầu từ gốc của hệ thống tệp, chỉ là thư mục trên cùng trong hệ thống phân cấp. Từ đó, mọi thứ được lồng vào nhau trong một cây thư mục, với mỗi thư mục trong đường dẫn tệp được phân tách bằng dấu gạch chéo. Bây giờ, nếu đường dẫn bạn đang xem trỏ đến một tệp, thì phần cuối cùng của đường dẫn tệp sẽ chỉ là tên của tệp. Nhưng nếu bạn đang xem một đường dẫn đến một thư mục, thì phần cuối cùng sẽ là tên của thư mục.

Để đưa ra một ví dụ trong hệ thống phân cấp này, đường dẫn đến `homework.txt` là `/documents/school/homework.txt` và đường dẫn đến thư mục `work` chỉ là `/documents/work`.

**Đường dẫn tệp:** Đầu ra của `pwd` hoặc print working directory là một đường dẫn tệp và một đường dẫn tệp chỉ là một chuỗi đại diện cho vị trí của chúng ta trên hệ thống. Vì vậy, một lần nữa, nếu bạn quen với giao diện người dùng đồ họa như Windows Explorer hoặc Finder, bạn có thể quen với việc nhìn thấy cây tệp một cách trực quan. Một đường dẫn tệp chỉ là một biểu diễn văn bản chính xác về vị trí của chúng ta. Tất nhiên, đường dẫn tệp có thể khó chịu khi gõ nếu chúng quá dài, nhưng khi bạn làm việc trong ngữ cảnh của một chương trình, sử dụng đường dẫn tệp để tham chiếu các tệp khác nhau trên hệ thống tệp ít bị lỗi hơn và thuận tiện hơn nhiều. Nó hoàn toàn dựa trên văn bản.

Hãy phân tích điều này: `/user/sl/lane`. Dấu gạch chéo đầu tiên đại diện cho thư mục gốc. Chúng ta đã đề cập đến điều này. Trong thư mục gốc, chúng ta có một thư mục `users` và sau đó trong thư mục đó, chúng ta có một thư mục `wags_lane`. Vì vậy, chúng ta thực sự xuống hai cấp từ gốc.

**Bài tập:** Đã đến lúc bắt đầu đào bới tìm kiếm bằng chứng. Nếu bạn đang sử dụng Windows, một lần nữa, hãy đảm bảo rằng bạn đã chuyển sang terminal WSL Ubuntu để điều này thực sự hoạt động. Bước đầu tiên, chúng ta sẽ tải xuống thư mục Ngân hàng Thế giới này. Nó đang được tải xuống từ GitHub của Boot.dev và chúng ta sẽ giải nén nó vào thư mục hiện tại của mình. Vì vậy, chúng ta đang ở trong thư mục chính của mình. Sao chép lệnh này, dán vào và chạy nó. Tôi sẽ nhập mật khẩu của mình và bây giờ tôi nên có một thư mục `world_bank`. Vì vậy, nếu tôi chạy `ls`, bạn có thể thấy tất cả những thứ trong thư mục chính của tôi. Và bây giờ bạn có thể thấy có một thư mục `world_bank` ở đó. Vì vậy, chúng ta sẽ thay đổi thư mục vào `world_bank` bằng lệnh `cd`. Bây giờ, đây là một thủ thuật nhỏ mà tôi nghĩ chúng ta sẽ đề cập sau trong khóa học, nhưng bạn sẽ thấy tôi làm điều đó và tự hỏi tôi đang làm gì. Nếu tôi bắt đầu gõ tên của một thư mục trong đường dẫn hiện tại và sau đó nhấn tab, nó sẽ tự động hoàn thành. Vì vậy, thư mục duy nhất trong thư mục hiện tại của tôi bắt đầu bằng `wrl` là `world_bank`, vì vậy tôi nhấn tab và nó tự động hoàn thành. Tôi có thể thay đổi thư mục vào `world_bank`. Tôi cũng có thể gõ toàn bộ nó ra. Không có gì sai với điều đó. Điều này sẽ không hoạt động vì tôi đã ở trong `world_bank`, nhưng bạn thấy nó hoạt động như thế nào. Và bây giờ bạn có thể thấy lời nhắc của tôi hơi khác. Chú ý rằng shell của tôi đang hiển thị cho tôi rằng tôi đang ở trong thư mục `world_bank`, trong khi trước đó tôi đang ở trong thư mục chính.

Bây giờ, trong `world_bank`, sử dụng lệnh `ls` một lần nữa để xem nội dung của thư mục `world_bank`. Vì vậy, `ls` để liệt kê và chúng ta có thể thấy bốn thứ khác nhau. Dán đầu ra vào trường văn bản. Vì vậy, chúng ta chỉ sao chép và dán. Nhân tiện, tôi sẽ sửa điều này sau khi tôi ghi lại video này. Tôi không nghĩ rằng `go.mod` nên ở đó. Nó sẽ không phá vỡ việc chúng ta nộp bài tập, nhưng nếu bạn làm điều này sau và nó biến mất, đó là vì nó không được cho là ở đó và tôi đã xóa nó. Vì vậy, đừng báo động nếu `go.mod` không còn ở đó.

**Tiếp theo:** Thư mục cha. Lệnh `cd` thay đổi thư mục để di chuyển vào một thư mục. Chúng ta đã đề cập đến điều đó. Nhưng làm thế nào để bạn thoát ra khỏi đó? Vì vậy, chúng ta đã thay đổi từ thư mục chính vào `world_bank`. Bây giờ chúng ta muốn thoát ra. Chúng ta có thể làm `cd ..`. Vì vậy, `..` về cơ bản là một biệt danh đặc biệt để quay lại một cấp thư mục. Một cấp thư mục duy nhất.

**Bài tập:** Điều hướng ra khỏi thư mục `world_bank`. Chúng ta vừa làm điều đó. Vì vậy, bạn ở trong thư mục cha của nó, trong trường hợp của chúng ta là thư mục chính. Sau đó, chạy lệnh `ls` một lần nữa, nhưng truyền tên của thư mục `world_bank` làm đối số. Vì vậy, nếu tôi chỉ gõ `ls` từ đây, vì tôi đang ở trong thư mục chính, tôi thấy mọi thứ trong thư mục chính. Nếu tôi muốn xem những gì trong `world_bank`, tôi có thể `cd` vào `world_bank` và sau đó chạy `ls`, theo mặc định sẽ in thư mục hiện tại. Hoặc tôi có thể truyền một đối số vào `ls` và nói, "Không, bạn biết đấy, tôi muốn liệt kê cụ thể nội dung của `world_bank`." Và sau đó chúng ta chỉ sao chép và dán điều này một lần nữa.

**Tiếp theo:** Đường dẫn tệp tuyệt đối so với tương đối. Cho đến nay, chúng ta chủ yếu đã xử lý các đường dẫn tệp tương đối. Chúng là các đường dẫn tệp tương đối so với vị trí hiện tại của chúng ta. Vì vậy, thư mục làm việc hiện tại của tôi là `/users/wags_lane/world_bank`. Như `ls world_bank`, đó là một đường dẫn tương đối vì tôi đang nói tôi muốn liệt kê nội dung của thư mục `world_bank`. Bạn có thể tìm nó tương đối so với nơi tôi hiện đang ở. `/users/wags_lane` là một đường dẫn tệp tuyệt đối vì nó cho chúng ta toàn bộ đường dẫn từ gốc. Vì vậy, sự khác biệt là các đường dẫn tệp tuyệt đối sẽ hoạt động bất kể bạn đang ở đâu trên hệ thống vì chúng luôn có thể được truy ngược về gốc. Chúng có thể bắt đầu từ đó và sau đó đi về phía trước. Một đường dẫn tệp tương đối phụ thuộc vào nơi bạn đang ở. Nó giống như bạn luôn có thể cho ai đó địa chỉ nhà của bạn và không quan trọng họ sống ở đâu, họ sẽ có thể tìm thấy địa chỉ của bạn vì địa chỉ của bạn là tuyệt đối. Bạn có thể nói với Amazon địa chỉ của bạn và họ có thể gửi một gói hàng đến bạn. Khi bạn đang đi dạo với bạn bè và muốn hướng dẫn họ đến nhà của bạn, bạn có thể nói, "Ồ, nhà tôi lên hai con phố và rẽ ở góc." Đó là một hướng dẫn tương đối. Nó phụ thuộc vào nơi bạn và bạn bè của bạn đang đứng tại thời điểm đó. Đó là một cách tuyệt vời để đưa ra hướng dẫn, nhưng bạn không thể nói với Amazon, "Nhà tôi lên hai con phố và rẽ ở góc." Nó không hoạt động như vậy.

Vì vậy, tất cả những điều này chỉ giải thích rằng vậy. Dấu hiệu là một đường dẫn tệp tuyệt đối luôn bắt đầu bằng dấu gạch chéo vì nó phải bắt đầu từ gốc, trong khi một đường dẫn tệp tương đối sẽ không bắt đầu bằng dấu gạch chéo và nó sẽ đi từ nơi bạn hiện đang ở.

Hãy để tôi cho bạn thấy ý tôi là gì. Tôi có thể làm `cd /users/wags_lane/world_bank`. Điều đó sẽ hoạt động. Đó là một đường dẫn tuyệt đối. Nếu từ đây tôi cố gắng vào thư mục `world_bank`, `cd world_bank`, nó sẽ không hoạt động vì không có thư mục `world_bank` bên trong thư mục `world_bank` nơi chúng ta đang ở. Nhưng nếu tôi đi lên một cấp, bây giờ vì có một thư mục `world_bank` ở đây, tôi có thể sử dụng một đường dẫn tương đối để quay lại vào nó.

**Câu hỏi:** Cái nào là đường dẫn tương đối?

- `/users/wags_lane/world_bank`
- `world_bank`
- `/world_bank`
- `/home/wags_lane/world_bank`

Đáp án: `world_bank` là đường dẫn tương đối duy nhất không bắt đầu bằng dấu gạch chéo.

**Câu hỏi khác:** Đường dẫn nào sẽ tham chiếu đến cùng một tệp bất kể thư mục làm việc hiện tại là gì? Đó sẽ là một đường dẫn tuyệt đối, một lần nữa, đường dẫn duy nhất bắt đầu bằng dấu gạch chéo.

**Tiếp theo:** Tệp. Bạn có thể đã quen thuộc với khái niệm tệp từ việc sử dụng GUI như Windows Explorer hoặc Finder. Và ở cốt lõi của chúng, các tệp thực sự chỉ là các khối dữ liệu. Thật dễ dàng để nghĩ về các tệp như một thứ gì đó cụ thể hơn nhiều. Bạn biết đấy, các loại tệp và siêu dữ liệu tệp tồn tại, nhưng điều quan trọng là phải hiểu rằng khi bạn bóc tất cả các lớp đó ra, một tệp thực sự chỉ là một khối byte mà hệ thống tệp của bạn theo dõi. Nó theo dõi vị trí của nó để bạn có thể tìm thấy nó bằng cách sử dụng một đường dẫn tệp.

Lệnh `cat` được sử dụng để xem nội dung của một tệp. Thật kỳ lạ, phải không? `cat` là gì? Nó là viết tắt của "concatenate", có nghĩa là nối. Và một lần nữaLinux không chỉ là một điều để khoe khoang với bạn đời tiềm năng. Kỹ năng Linux và rộng hơn là khả năng sử dụng dòng lệnh, shell, terminal sẽ hữu ích trong bất kỳ công việc kỹ sư phần mềm nào, thậm chí trong các công việc DevOps, IT hoặc tự động hóa. Nếu bạn làm việc gần với internet, hiểu biết về Linux sẽ là một công cụ vô giá trong bộ kỹ năng của bạn. Trong video này, tôi sẽ hướng dẫn bạn toàn bộ khóa học giới thiệu về Linux trên boot.dev. Nhưng trước tiên, tôi muốn giải thích rõ khóa học này là gì và không phải là gì.

Tôi gọi nó là "Học Linux" chỉ vì đó là cách hầu hết mọi người nghĩ về nó và liên tưởng terminal với Linux. Khi họ nghĩ về `ls`, `cd`, `grep`, `find`, họ nghĩ về Linux. Nhưng thành thật mà nói, tên của khóa học hơi sai lệch. Nó nên được gọi là "Học cách sử dụng shell và terminal trong môi trường giống Unix." Đó là một hệ thống Unix, tôi biết điều này. Vì vậy, chúng ta sẽ tập trung vào shell và terminal trong khóa học này, và bạn có thể sử dụng Linux hoặc Mac, cả hai đều là hệ thống giống Unix. Điều hướng dòng lệnh trên các hệ điều hành này cảm giác khá giống nhau. Nếu bạn đang sử dụng Windows, đừng lo lắng, chúng tôi sẽ thiết lập cho bạn môi trường WSL (Windows Subsystem for Linux) để bạn có thể theo dõi trên Ubuntu.

Các chương trong khóa học này bao gồm: Terminal và shell, hệ thống tệp, quyền, chương trình, đầu vào/đầu ra và trình quản lý gói. Mục tiêu của khóa học là khi bạn hoàn thành, bạn sẽ cảm thấy rất thoải mái khi sử dụng terminal để thực hiện công việc hàng ngày của mình, cả trên Linux và Mac. Nếu bạn đang làm việc với các máy chủ từ xa, chẳng hạn như máy chủ web Linux từ xa, bạn sẽ cảm thấy rất thoải mái khi điều hướng hệ thống tệp trên loại máy chủ đó.

Tuy nhiên, đây không phải là khóa học về nhân Linux, hệ điều hành hoặc quản trị máy chủ. Khóa học này thực sự là điều kiện tiên quyết cho các loại khóa học đó. Khóa học Linux này là khóa học số hai trên lộ trình phát triển backend trên boot.dev, và đó là lý do tại sao tất cả các kỹ năng shell và terminal mà bạn sẽ học trong khóa học này không chỉ là điều mà mọi nhà phát triển backend nên có, mà tôi thực sự tin rằng mọi nhà phát triển nói chung nên hiểu cách điều hướng dòng lệnh.

Nhân tiện, để bạn biết ai đang dạy bạn, tôi là Lane, người tạo ra boot.dev, một nền tảng tương tác cho giáo dục kỹ thuật phần mềm. Tôi đã viết mã trong khoảng 15 năm và làm việc chuyên nghiệp trong khoảng 8 năm. Tôi chủ yếu chuyên về backend và kỹ thuật dữ liệu, nhưng giống như hầu hết các nhà phát triển, tôi đã thử nghiệm khắp các lớp của stack.

Bây giờ, hãy nói về cách bạn sẽ hoàn thành khóa học này. Tùy chọn một là lấy một túi bỏng ngô, ngồi xuống và xem tôi làm tất cả công việc cho bạn. Bạn có thể giả vờ rằng bạn đang học khi tôi gõ mọi thứ. Đó không phải là một lựa chọn tốt. Nếu bạn xem toàn bộ khóa học này mà không tạm dừng, bạn đã làm sai. Vì vậy, hãy đảm bảo rằng bạn đang ở trước một máy tính mà bạn có quyền truy cập vào terminal và thực sự làm theo khi chúng ta đi qua toàn bộ khóa học này.

Nội dung của khóa học này, giống như tất cả các khóa học trên boot.dev, hoàn toàn miễn phí. Tôi thực sự khuyên bạn nên truy cập boot.dev, tạo một tài khoản miễn phí và làm theo tất cả các hướng dẫn văn bản khi bạn xem video này. Điều làm cho mô hình nội dung miễn phí này hoạt động là tất cả các tính năng tương tác trên boot.dev sau một thời điểm nhất định sẽ phải trả phí. Nếu bạn thích tất cả các tính năng gamification, nếu bạn thích tính năng xem trước giải pháp, trợ lý AI, chứng chỉ, tất cả những thứ đó sẽ có sẵn với tư cách thành viên trả phí. Nhưng bạn không cần tư cách thành viên trả phí để tham gia khóa học này. Nhưng nếu bạn muốn trở thành thành viên, tôi có mã giảm giá cho bạn. Bạn có thể sử dụng mã `boots` để được giảm giá 25% cho năm đầu tiên nếu bạn chọn gói hàng năm.

Bây giờ, đủ với việc quảng cáo, hãy nói về điều gì sẽ xảy ra nếu bạn bị kẹt trong khóa học này. Làm ơn đừng yêu cầu trợ giúp trong phần bình luận trên YouTube. Tôi không thể giúp bạn một cách hợp lý ở đó. Hãy tham gia Discord của boot.dev, hoàn toàn miễn phí để tham gia. Hãy thoải mái đặt câu hỏi ở đó.

Bây giờ, hãy nói về shell, terminal và Linux. Được rồi, tôi đang ở đây trong khóa học "Học Linux", khóa học "Học shell và terminal" trên boot.dev, và hãy bắt đầu. Chỉ để cho bạn biết một chút về bố cục, tôi có trình giả lập terminal ở bên phải, đây là Ghostty, và tôi có các hướng dẫn bài học ở phía bên trái màn hình. Trong bài học đầu tiên này, tôi sẽ bỏ qua phần đầu tiên vì chúng ta đã đề cập đến nó trong phần giới thiệu của video này. Vì vậy, chúng ta sẽ đi thẳng vào bài tập.

Được rồi, hãy tìm và mở một terminal trên máy tính của bạn. Tôi đã mở Ghostty, tôi đang sử dụng Mac OS. Nếu bạn đang sử dụng Mac, bạn có thể sử dụng Ghostty hoặc terminal tích hợp sẵn. Nếu bạn đang sử dụng Windows, bạn có thể mở Command Prompt. Và nếu bạn đang sử dụng Linux, hy vọng bạn biết terminal của mình ở đâu. Vì vậy, chúng ta sẽ chỉ cần sao chép lệnh này, dán vào terminal và chạy nó: `echo hello world`. Nó sẽ in lại "hello world" vào console. Sau khi làm xong, hãy trả lời câu hỏi: "Điều gì đã xảy ra khi bạn nhấn Enter?" Câu trả lời là: "Văn bản 'hello world' được in ra terminal console." Khá đơn giản. Nếu bạn đến từ thế giới Python, nó giống như `print("hello world")`, hoặc trong Go là `fmt.Println("hello world")`. Đây là tương đương của terminal hoặc shell với việc in "hello world".

Các từ như terminal, shell, dòng lệnh, CLI và Command Prompt thường được các lập trình viên sử dụng một cách bừa bãi. Mặc dù các định nghĩa chính xác có thể hơi khác nhau, chúng ta thường đang nói về một chương trình cho phép bạn tương tác với máy tính của mình thông qua văn bản. Nếu bạn mới làm quen với dòng lệnh, bạn có thể đã quen với GUI (Giao diện người dùng đồ họa), và GUI chỉ là một giao diện trực quan cho phép bạn thực hiện các công việc trên máy tính. Hãy nghĩ đến một màn hình desktop của Windows, nó có các menu để lướt qua, các biểu tượng để nhấp vào và thậm chí các hệ thống quản lý cửa sổ phức tạp. CLI (Giao diện dòng lệnh) là một lựa chọn thay thế đơn giản hơn nhiều. Thay vì sử dụng các nút và menu trực quan phức tạp, bạn tương tác hoàn toàn thông qua văn bản. Muốn chạy một chương trình? Đừng nhấp vào biểu tượng, chỉ cần gõ tên chương trình. Muốn xem một tệp? Đừng mở Microsoft Word, chỉ cần gõ một lệnh.

Trong khi GUI có rào cản thấp hơn để sử dụng, chúng cũng khá hạn chế. Giao diện dòng lệnh mạnh mẽ hơn vì bạn không bị giới hạn bởi các nút và widget mà các nhà phát triển ứng dụng cung cấp. Thay vào đó, bạn có quyền truy cập trực tiếp vào các cấp độ thấp hơn của hệ thống của mình. Là một lập trình viên, việc thành thạo dòng lệnh là điều bắt buộc.

Được rồi, tiếp theo là so sánh giữa dòng lệnh và GUI. Trong tất cả các khóa học khác trên boot.dev, hoặc tôi nên nói là các khóa học dành cho người mới bắt đầu, bạn sẽ viết mã chủ yếu trong trình duyệt của mình, và khi bạn muốn chạy mã, bạn sẽ nhấp vào nút "Run". Nhưng thông thường, với tư cách là một nhà phát triển thực sự, và điều này không hoàn toàn đúng vì nó thiên về kinh nghiệm của tôi với tư cách là một nhà phát triển web, nhưng rất thường xuyên bạn sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ, có những IDE ngoài kia mà bạn nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn chúng ta, những người sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất tốt vì bạn sẽ sử dụng nó. Ví dụ, khi tôi viết mã Python, tôi thường chạy mã của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình soạn thảo của tôi. Đó chỉ là cách tôi thích viết mã, hoặc tôi nên nói là thiết lập môi trường phát triển của mình.

Vậy, CLI là gì? Nó là viết tắt của Command Line Interface, nhưng nó là một giao diện văDưới đây là bản dịch tiếng Việt của bài giảng trên:

---

Linux không chỉ là một thứ để khoe khoang với các đối tác tiềm năng. Kỹ năng Linux, và rộng hơn là khả năng sử dụng dòng lệnh (command line, shell, terminal), sẽ rất hữu ích trong bất kỳ công việc kỹ sư phần mềm nào, thậm chí trong các công việc DevOps, IT, hay tự động hóa. Nếu bạn làm việc liên quan đến internet, hiểu biết về Linux sẽ là một công cụ vô giá trong bộ kỹ năng của bạn. Trong video này, tôi sẽ hướng dẫn bạn toàn bộ khóa học giới thiệu về Linux trên boot.dev. Nhưng trước tiên, tôi muốn giải thích chính xác khóa học này là gì và không phải là gì.

Tôi gọi nó là "Học Linux" vì đó là cách mọi người thường nghĩ đến khi họ liên tưởng đến terminal. Khi họ nghĩ về `ls`, `cd`, `grep`, `find`, họ nghĩ đến Linux. Nhưng thực ra, tên của khóa học này hơi gây hiểu lầm. Nó nên được gọi là "Học cách sử dụng shell và terminal trong môi trường Unix-like". Vì thế, trong khóa học này, chúng ta sẽ tập trung vào shell và terminal, và bạn có thể sử dụng Linux hoặc Mac, cả hai đều là hệ thống Unix-like. Việc điều hướng dòng lệnh trên các hệ điều hành này khá giống nhau. Nếu bạn đang sử dụng Windows, đừng lo, chúng tôi sẽ thiết lập cho bạn một môi trường WSL (Windows Subsystem for Linux) để bạn có thể làm theo trên Ubuntu.

Các chương trong khóa học này bao gồm: Terminal và shell, hệ thống tệp, quyền (permissions), chương trình, đầu vào/đầu ra và trình quản lý gói (package managers). Mục tiêu của khóa học là sau khi hoàn thành, bạn sẽ cảm thấy rất thoải mái khi sử dụng terminal để thực hiện công việc hàng ngày, cả trên Linux và Mac. Nếu bạn làm việc với các máy chủ từ xa, ví dụ như các máy chủ web Linux từ xa, bạn sẽ cảm thấy tự tin khi điều hướng hệ thống tệp trên loại máy chủ đó.

Tuy nhiên, đây không phải là một khóa học về nhân Linux, hệ điều hành, hay quản trị máy chủ. Khóa học này thực sự là một điều kiện tiên quyết cho các loại khóa học đó. Khóa học Linux này là khóa học số 2 trong lộ trình phát triển backend developer trên boot.dev, và lý do là vì tất cả các kỹ năng về shell và terminal mà bạn sẽ học trong khóa học này không chỉ cần thiết cho mọi backend developer, mà tôi thực sự tin rằng mọi developer nói chung nên hiểu cách điều hướng dòng lệnh.

Nhân tiện, để bạn biết ai đang dạy bạn, tôi là Lane, người tạo ra boot.dev, một nền tảng tương tác cho giáo dục kỹ thuật phần mềm. Tôi đã viết code khoảng 15 năm và làm chuyên nghiệp khoảng 8 năm. Tôi chủ yếu chuyên về backend và data engineering, nhưng giống như hầu hết các developer, tôi cũng đã thử nghiệm ở nhiều lĩnh vực khác nhau.

Bây giờ, hãy nói về cách bạn sẽ hoàn thành khóa học này. Lựa chọn thứ nhất là lấy một túi bỏng ngô, ngồi xuống và xem tôi làm mọi thứ cho bạn. Bạn có thể giả vờ như bạn đang học khi tôi gõ mọi thứ. Đó không phải là một lựa chọn tốt. Nếu bạn xem toàn bộ khóa học mà không tạm dừng, bạn đã làm sai. Vì vậy, hãy đảm bảo rằng bạn đang ở trước máy tính, có quyền truy cập vào terminal và thực sự làm theo khi chúng ta đi qua toàn bộ khóa học.

Nội dung của khóa học này, giống như tất cả các khóa học trên boot.dev, hoàn toàn miễn phí. Tôi rất khuyến khích bạn truy cập boot.dev, tạo một tài khoản miễn phí và làm theo các hướng dẫn văn bản khi bạn xem video này. Điều khiến mô hình nội dung miễn phí này hoạt động là tất cả các tính năng tương tác trên boot.dev sau một thời điểm nhất định sẽ là tính năng trả phí. Nếu bạn thích các tính năng trò chơi hóa, tính năng xem giải pháp, trợ lý AI, chứng chỉ, tất cả những thứ đó sẽ có sẵn với tư cách thành viên trả phí. Nhưng bạn không cần phải là thành viên trả phí để tham gia khóa học này. Nếu bạn muốn trở thành thành viên, tôi có mã giảm giá cho bạn. Bạn có thể sử dụng mã "boots" để giảm 25% cho năm đầu tiên nếu bạn chọn gói hàng năm.

Đủ với việc quảng cáo, hãy nói về điều gì sẽ xảy ra nếu bạn bị kẹt trong khóa học này. Xin đừng yêu cầu trợ giúp trong phần bình luận trên YouTube. Tôi không thể giúp bạn một cách hợp lý ở đó. Hãy tham gia Discord của boot.dev, hoàn toàn miễn phí, và thoải mái đặt câu hỏi ở đó.

Bây giờ, hãy nói về shell, terminal và Linux. Tôi đang ở trong khóa học "Học Linux" hay còn gọi là "Học shell và terminal" trên boot.dev, và chúng ta sẽ bắt đầu. Chỉ để cho bạn hình dung, tôi có terminal emulator của mình ở bên phải, đây là Ghostty, và tôi có các hướng dẫn bài học ở phía bên trái màn hình. Trong bài học đầu tiên này, tôi sẽ bỏ qua phần đầu tiên vì chúng ta đã nói về nó trong phần giới thiệu của video này. Vì vậy, hãy đi thẳng vào bài tập.

Bài tập đầu tiên là tìm và mở một terminal trên máy tính của bạn. Tôi đã mở Ghostty, tôi đang sử dụng Mac OS. Nếu bạn đang sử dụng Mac, bạn có thể sử dụng Ghostty hoặc terminal tích hợp sẵn. Nếu bạn đang sử dụng Windows, bạn có thể mở Command Prompt, và nếu bạn đang sử dụng Linux, hy vọng bạn biết terminal của mình ở đâu. Chúng ta sẽ dán lệnh này vào terminal và chạy nó: `echo "Hello World"`. Nó sẽ in ra "Hello World" trên console. Sau đó, chúng ta sẽ trả lời câu hỏi: "Điều gì xảy ra khi bạn nhấn Enter?" Văn bản "Hello World" được in ra terminal console, khá đơn giản. Nếu bạn đến từ thế giới Python, nó giống như `print("Hello World")`, hoặc trong Go, `fmt.Println("Hello World")`. Đây là phiên bản terminal hoặc shell tương đương với `print("Hello World")`.

Các từ như terminal, shell, command line, CLI và command prompt thường được các lập trình viên sử dụng một cách tùy tiện. Mặc dù định nghĩa chính xác của chúng có thể hơi khác nhau, nhưng chúng ta thường đang nói về một chương trình cho phép bạn tương tác với máy tính của mình thông qua văn bản. Nếu bạn mới làm quen với dòng lệnh, bạn có lẽ đã quen thuộc với GUI (Graphical User Interface). GUI là một giao diện trực quan cho phép bạn thực hiện các tác vụ trên máy tính. Ví dụ, một desktop Windows có các menu để duyệt qua, các biểu tượng để nhấp vào, và thậm chí các hệ thống quản lý cửa sổ phức tạp. CLI (Command Line Interface) là một lựa chọn đơn giản hơn nhiều. Thay vì sử dụng các nút và menu trực quan phức tạp, bạn tương tác hoàn toàn thông qua văn bản. Bạn muốn chạy một chương trình? Đừng nhấp vào biểu tượng, chỉ cần gõ tên của chương trình. Bạn muốn xem một tệp? Đừng mở Microsoft Word, chỉ cần gõ một lệnh.

Mặc dù GUI có rào cản thấp hơn để sử dụng (tức là chúng thường dễ hiểu), chúng cũng khá hạn chế. Một giao diện dòng lệnh mạnh mẽ hơn vì bạn không bị giới hạn bởi các nút và widget được cung cấp bởi các nhà phát triển ứng dụng. Thay vào đó, bạn có quyền truy cập trực tiếp vào các cấp độ thấp hơn của hệ thống. Là một lập trình viên, việc thoải mái với dòng lệnh là điều bắt buộc.

**Tiếp theo:**

**Command Line vs. GUI (Giao diện người dùng đồ họa)**

Trong các khóa học khác trên boot.dev, hoặc ít nhất là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình. Và khi bạn muốn chạy code, bạn sẽ nhấp vào nút "Run". Tuy nhiên, thực tế là, khi bạn trở thành một nhà phát triển thực thụ (và điều này không hoàn toàn đúng, nó hơi thiên về kinh nghiệm của tôi với tư cách là một nhà phát triển web), bạn thường sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ. Có những IDE (Integrated Development Environment) ngoài kia mà bạn nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn những người sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất tốt vì bạn sẽ sử dụng nó. Ví dụ, khi tôi viết code Python, tôi thường chạy code của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình soạn thảo của tôi. Đó chỉ là cách tôi thích viết code, hoặc tôi nên nói là cách tôi thiết lập môi trường phát triển của mình.

**Vậy, CLI là gì?**

CLI là viết tắt của Command Line Interface, nhưng nó là một giao diện văn bản để tương tác với các ứng dụng và chương trình. Nếu bạn không đến từ nền tảng phát triển, bạn có thể quen với việc tương tác với máy tính của mình thông qua giao diện người dùng đồ họa. Bạn nhấp vào các biểu tượng khác nhau, bạn điều hướng cấu trúc thư mục bằng cách sử dụng thứ gì đó như Windows Explorer hoặc Finder trên Mac, và bạn sử dụng chuột rất nhiều. Bạn đang nhìn vào hình ảnh, bạn đang nhấp vào các thứ. Đó là giao diện người dùng đồ họa. Một giao diện dòng lệnh chỉ có văn bản, nghĩa là nó sẽ khó học hơn vì bạn phTiếp tục bản dịch bài giảng trên:

---

**Command Line vs GUI (Giao diện người dùng đồ họa):**

Trong tất cả các khóa học khác trên Boot.dev, hoặc ít nhất là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình, và khi bạn muốn chạy code, bạn sẽ nhấp vào nút "Run". Tuy nhiên, thông thường, với tư cách là một nhà phát triển thực thụ (và điều này không hoàn toàn đúng, nó hơi thiTiếp theo, chúng ta sẽ nói về **Command Line** so với **GUI** (Giao diện người dùng đồ họa). Trong hầu hết các khóa học khác trên boot.dev, đặc biệt là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình. Khi bạn muốn chạy code, bạn sẽ nhấp vào nút "Run". Tuy nhiên, trong thực tế, khi bạn là một nhà phát triển thực thụ (đặc biệt là trong lĩnh vực web development, như kinh nghiệm của tôi), bạn thường sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ. Có những IDE (Integrated Development Environment) nơi bạn nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn những người sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất quan trọng vì bạn sẽ sử dụng nó rất nhiều. Ví dụ, khi tôi viết code Python, tôi thường chạy code của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình soạn thảo của tôi. Đó là cách tôi thích thiết lập môi trường phát triển của mình.

Vậy, **CLI** là gì? Nó là viết tắt của **Command Line Interface**, nhưng nó là một giao diện văn bản để tương tác với các ứng dụng và chương trình. Nếu bạn không đến từ nền tảng phát triển, bạn có thể quen với việc tương tác với máy tính của mình thông qua giao diện người dùng đồ họa (GUI). Bạn nhấp vào các biểu tượng khác nhau, bạn điều hướng cấu trúc thư mục bằng cách sử dụng thứ gì đó như Windows Explorer hoặc Finder trên Mac, và bạn sử dụng chuột rất nhiều. Bạn đang nhìn vào hình ảnh, bạn đang nhấp vào các thứ — đó là giao diện người dùng đồ họa. Một giao diện dòng lệnh chỉ có văn bản, nghĩa là nó sẽ khó học hơn vì bạn phải học tất cả các lệnh khác nhau. Nhưng một khi bạn biết các lệnh, nó thực sự nhanh hơn rất nhiều để sử dụng giao diện dòng lệnh vì nó chỉ là văn bản, và bạn có thể đi nhanh như bạn có thể gõ. Nó cũng làm cho việc tự động hóa mọi thứ trở nên dễ dàng hơn rất nhiều vì viết một chương trình hoạt động với văn bản dễ dàng hơn nhiều so với viết một chương trình giả lập các cú nhấp chuột và những thứ tương tự.

**Bài tập:** Trong terminal của bạn, chạy lệnh sau: `whoami`. Tôi nhận được kết quả là "wags_lane". Đó là tài khoản người dùng đăng nhập của tôi trên Mac. Khi chúng ta hoàn thành, hãy trả lời câu hỏi: "Điều gì xảy ra khi bạn chạy lệnh?" Tên người dùng của tôi được in ra console.

---

**Bài học tiếp theo: Cài đặt Windows Subsystem for Linux (WSL).**

Tôi sẽ bỏ qua phần này vì tôi không sử dụng Windows. Nếu bạn đang sử dụng Windows, bạn sẽ không thể sử dụng Command Prompt mặc định cho phần còn lại của khóa học. Bạn sẽ sử dụng Linux chạy trên máy Windows của mình với WSL. Nếu bạn đang sử dụng Windows và cần thiết lập WSL, hãy đến bài học này, đó là bài học số 3 trong chương 1. Tất cả các hướng dẫn đều ở đây. Điều này đã được kiểm tra kỹ lưỡng. Chúng tôi đã có hàng ngàn sinh viên cài đặt và sử dụng WSL. Đừng lo, nó sẽ không làm hỏng cài đặt Windows của bạn. Đây không phải là tình huống dual boot nơi bạn phải phân vùng ổ đĩa. Không có gì điên rồ như vậy. Nó thực sự khá đơn giản để thiết lập. Đó là lTiếp theo phần bản dịch:

---

**Tiếp theo: Dòng lệnh so với GUI (Giao diện đồ họa người dùng)**

Trong tất cả các khóa học khác trên boot.dev, hoặc ít nhất là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình. Khi bạn muốn chạy code, bạn sẽ nhấp vào nút "Run". Tuy nhiên, thông thường, với tư cách là một nhà phát triển thực thụ (và điều này không hoàn toàn đúng, nó hơi thiên về kinh nghiệm của tôi với tư cách là một nhà phát triển web), bạn sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ. Có những IDE (Môi trường phát triển tích hợp) nơi bạn nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn chúng ta, những người sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất tốt vì bạn sẽ sử dụng nó. Ví dụ, khi tôi viết code Python, tôi thường chạy code của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình soạn thảo của tôi. Đó chỉ là cách tôi thích viết code, hoặc tôi nên nói là thiết lập môi trường phát triển của mình.

Vậy, CLI là gì? Nó là viết tắt của Command Line Interface, nhưng nó là một giao diện văn bản để tương tác với các ứng dụng và chương trình. Nếu bạn không đến từ nền tảng phát triển, bạn có thể quen với việc tương tác với máy tính của mình thông qua giao diện người dùng đồ họa. Bạn nhấp vào các biểu tượng khác nhau, bạn điều hướng cấu trúc thư mục bằng cách sử dụng thứ gì đó như Windows Explorer hoặc Finder trên Mac, và bạn sử dụng chuột rất nhiều. Bạn đang nhìn vào hình ảnh, bạn đang nhấp vào các thứ. Đó là giao diện người dùng đồ họa. Một giao diện dòng lệnh chỉ có văn bản, nghĩa là nó sẽ khó học hơn vì bạn phải học tất cả các lệnh khác nhau. Nhưng một khi bạn biết các lệnh, nó thực sự nhanh hơn rất nhiều để sử dụng giao diện dòng lệnh vì nó chỉ là văn bản và bạn có thể đi nhanh như bạn có thể gõ. Nó cũng làm cho việc tự động hóa mọi thứ trở nên dễ dàng hơn nhiều vì viết một chương trình hoạt động với văn bản dễ dàng hơn nhiều so với viết một chương trình cố giả lập các cú nhấp chuột và những thứ tương tự.

**Bài tập:** Trong terminal của bạn, chạy lệnh sau: `whoami`. Tôi nhận được kết quả là "wags_lane". Đó là tài khoản người dùng đăng nhập của tôi trên Mac. Khi chúng ta hoàn thành, hãy trả lời câu hỏi: "Điều gì đã xảy ra khi bạn chạy lệnh?" Tên người dùng của tôi được in ra console.

**Bài học tiếp theo:** Cài đặt Windows Subsystem for Linux (WSL). Tôi sẽ bỏ qua phần này vì tôi không sử dụng Windows. Nếu bạn đang sử dụng Windows, bạn sẽ không thể sử dụng Command Prompt mặc định cho phần còn lại của khóa học. Bạn sẽ sử dụng Linux chạy trên máy Windows của mình với WSL. Nếu bạn đang sử dụng Windows và cần thiết lập WSL, hãy đến bài học này, đó là bài học số 3 trong chương 1. Tất cả các hướng dẫn đều ở đây. Điều này đã được kiểm tra kỹ lưỡng. Chúng tôi đã có hàng ngàn sinh viên cài đặt và sử dụng WSL. Đừng lo, nó sẽ không làm hỏng cài đặt Windows của bạn. Đây không phải là tình huống dual boot nơi bạn phải phân vùng ổ đĩa. Không có gì điên rồ như vậy. Nó thực sự khá đơn giản để thiết lập. Đó là lý do tại sao chúng tôi khuyên dùng nó. Vì vậy, nếu bạn đang sử dụng Windows và cần thiết lập WSL, hãy làm điều đó. Khi bạn hoàn thành, bạn sẽ có một terminal Linux, một shell Linux mà bạn có thể sử dụng. Nó sẽ là bash, và bạn sẽ có thể theo dõi phần còn lại của khóa học. Trong phần còn lại của khóa học, mọi thứ chúng ta làm sẽ hoạt động với bash và zsh, hai shell trên Linux và Mac, và sẽ không cần nhiều tùy chỉnh. Cả Linux và Mac đều là hệ thống giống Unix, và tất cả những gì chúng ta sẽ đề cập ở đây đủ giống nhau để hoạt động. Vì vậy, chúng ta sẽ bỏ qua phần đó.

**Tiếp theo: Terminal là gì?**

Là các nhà phát triển, đôi khi chúng ta sử dụng tất cả các thuật ngữ này thay thế cho nhau. Các thuật ngữ đó là gì? Terminal, shell, command line interface (CLI). Bạn thường nghe các nhà phát triển sử dụng các từ khác nhau để chỉ cùng một thứ, về cơ bản có nghĩa là tôi đang nhập văn bản vào terminal của mình. Vì vậy, chỉ cần hiểu rằng chúng ta thường có nghĩa giống nhau và chúng ta hơi lỏng lẻo với từ ngữ. Nhưng chúng thực sự có các định nghĩa khác nhau. Một terminal, để thực sự chính xác, thực sự không tồn tại trên máy tính của bạn. Một terminal là một thiết bị vật lý, như hình ảnh lớn này ở đây. Ngày xưa, bạn phải có một terminal. Bạn có thể nghĩ nó giống như một combo màn hình và bàn phím. Nó là thứ cho phép bạn tương tác với phần mềm. Đó là một terminal vật lý. Ngày nay, chúng ta không sử dụng những thứ đó thường xuyên. Chúng ta sử dụng terminal emulator. Đó là những gì Ghostty là. Đó là một chương trình trên máy tính của tôi mô phỏng một terminal. Nó cho phép tôi nhập văn bản và hiển thị văn bản trở lại tôi. Vì vậy, để thực sự chính xác, một terminal chỉ là nơi bạn có thể nhập văn bản và nơi có thể hiển thị văn bản trở lại.

**Câu hỏi:** Một terminal hoặc terminal emulator là gì?

- Một hệ điều hành dựa trên văn bản
- Một tập hợp các lệnh có thể được sử dụng để điều khiển máy tính
- Một chương trình chấp nhận các lệnh dựa trên văn bản và có thể hiển thị văn bản trên màn hình
- Một Raspberry Pi mới ra lò

Đáp án: Một chương trình chấp nhận các lệnh dựa trên văn bản và có thể hiển thị văn bản trên màn hình.

Vì vậy, nếu đó là terminal, thì tôi không muốn xúc phạm bất kỳ ai làm việc trên terminal, nhưng khi so sánh với shell, terminal có thể được coi là khá "ngu ngốc". Nó không thực sự phải diễn giải các lệnh. Tất cả những gì nó phải làm là chấp nhận văn bản và hiển thị văn bản. Vì vậy, shell là chương trình thực sự cung cấp khả năng tương tác trong terminal. Nó chờ đợi lời nhắc, xử lý lời nhắc, diễn giải lời nhắc, thực thi lời nhắc và sau đó cung cấp cho bạn một lời nhắc mới khi nó hoàn thành xử lý lời nhắc cũ. Từ viết tắt cho điều này là REPL (Read-Evaluate-Print Loop). Vì vậy, khi chúng ta gõ một lệnh như `echo Hello World`, khi tôi nhấn Enter, điều đầu tiên shell làm là đọc `echo Hello World`. Nó đánh giá nó: "Tôi nên làm gì với lời nhắc này?" NóTiếp theo phần trước, chúng ta sẽ tiếp tục với các nội dung quan trọng trong bài giảng về Linux, shell và terminal.

---

### **Tiếp theo: Command Line vs GUI (Giao diện người dùng đồ họa)**

Trong các khóa học khác trên **boot.dev**, đặc biệt là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt. Khi bạn muốn chạy code, bạn sẽ nhấp vào nút **"Run"**. Tuy nhiên, trong thực tế, khi bạn là một nhà phát triển thực thụ (đặc biệt là trong lĩnh vực phát triển web), bạn thường sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ, chẳng hạn như các IDE (Môi trường phát triển tích hợp) nơi bạn có thể nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn những người sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất quan trọng vì bạn sẽ sử dụng nó rất nhiều. Ví dụ, khi tôi viết code Python, tôi thường chạy code của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình soạn thảo. Đó là cách tôi thiết lập môi trường phát triển của mình.

Vậy, **CLI (Command Line Interface)** là gì? Nó là viết tắt của **Command Line Interface**, nhưng nó thực sự là một giao diện văn bản để tương tác với các ứng dụng và chương trình. Nếu bạn không đến từ nền tảng phát triển, bạn có thể quen với việc tương tác với máy tính thông qua **GUI (Graphical User Interface)**. Bạn nhấp vào các biểu tượng, điều hướng cấu trúc thư mục bằng cách sử dụng **Windows Explorer** hoặc **Finder** trên Mac, và bạn sử dụng chuột rất nhiều. Bạn nhìn vào hình ảnh, bạn nhấp vào các thứ. Đó là GUI. Một **CLI** chỉ có văn bản, nghĩa là nó sẽ khó học hơn vì bạn phải học tất cả các lệnh khác nhau. Nhưng một khi bạn biết các lệnh, nó thực sự nhanh hơn rất nhiều để sử dụng CLI vì nó chỉ là văn bản, và bạn có thể làm việc nhanh như bạn gõ. Nó cũng giúp việc tự động hóa trở nên dễ dàng hơn nhiều vì viết một chương trình hoạt động với văn bản dễ dàng hơn nhiều so với viết một chương trình cố giả lập các cú nhấp chuột.

---

### **Bài tập: Sử dụng lệnh `whoami`**

Trong terminal của bạn, chạy lệnh sau:

```bash
whoami
```

Kết quả của tôi là `wags_lane`. Đó là tên người dùng đăng nhập của tôi trên Mac. Khi bạn hoàn thành, hãy trả lời câu hỏi: **"**Tiếp theo: Command Line vs GUI (Giao diện người dùng đồ họa)\*\*

Trong tất cả các khóa học khác trên Boot.dev, hoặc ít nhất là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình. Và khi bạn muốn chạy code, bạn sẽ nhấp vào nút "Run". Tuy nhiên, thông thường, là một nhà phát triển thực thụ (và điều này không hoàn toàn đúng, vì nó hơi thiên về kinh nghiệm của tôi với tư cách là một nhà phát triển web), nhưng rất thường xuyên, bạn sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có**Tiếp theo:**

**Tiếp theo: Command Line vs GUI (Giao diện người dùng đồ họa)**

Trong tất cả các khóa học khác trên boot.dev, hoặc ít nhất là các khóa học dành cho người mới bắt đầu, bạn sẽ viết code chủ yếu trong trình duyệt của mình. Và khi bạn muốn chạy code của mình, bạn sẽ nhấp vào nút "Run". Tuy nhiên, thông thường, là một nhà phát triển thực thụ (và điều này không hoàn toàn đúng, nó hơi thiên về kinh nghiệm của tôi với tư cách là một nhà phát triển web), nhưng thường xuyên, bạn sẽ chạy các chương trình của mình từ dòng lệnh thay vì nhấp vào nút "Run". Tất nhiên, có những ngoại lệ. Có những IDE ngoài kia nơi bạn nhấp vào nút "Run", và những nhà phát triển đó không kém chuyên nghiệp hơn những người trong chúng ta sử dụng dòng lệnh. Nhưng việc làm quen với dòng lệnh là rất tốt vì bạn sẽ sử dụng nó. Ví dụ, khi tôi viết code Python, tôi thường chạy code của mình bằng cách gõ `python main.py` vào terminal thay vì nhấp vào nút "Run" trong trình chỉnh sửa của tôi. Đó chỉ là cách tôi thích thiết lập môi trường phát triển của mình.

Vậy, CLI là gì? Nó là viết tắt của Command Line Interface, nhưng nó là một giao diện văn bản để tương tác với các ứng dụng và chương trình. Nếu bạn không đến từ nền tảng phát triển, bạn có thể quen với việc tương tác với máy tính của mình thông qua giao diện người dùng đồ họa. Bạn nhấp vào các biểu tượng khác nhau, bạn điều hướng cấu trúc thư mục bằng cách sử dụng thứ gì đó như Windows Explorer hoặc Finder trên Mac, và bạn sử dụng chuột rất nhiều. Bạn đang nhìn vào hình ảnh, bạn đang nhấp vào các thứ. Đó là giao diện người dùng đồ họa. Một giao diện dòng lệnh chỉ có văn bản, nghĩa là nó sẽ khó học hơn vì bạn phải học tất cả các lệnh khác nhau. Nhưng một khi bạn biết các lệnh, nó thực sự nhanh hơn rất nhiều để sử dụng giao diện dòng lệnh vì nó chỉ là văn bản và bạn có thể đi nhanh như bạn có thể gõ. Nó cũng làm cho việc tự động hóa mọi thứ trở nên dễ dàng hơn nhiều vì viết một chương trình hoạt động với văn bản dễ dàng hơn nhiều so với viết một chương trình cố giả lập các cú nhấp chuột và những thứ tương tự.

**Bài tập:** Trong terminal của bạn, chạy lệnh sau: `whoami`. Tôi được kết quả là "wags_lane". Đó là tài khoản người dùng đăng nhập của tôi trên Mac. Khi chúng ta hoàn thành, hãy trả lời câu hỏi: "Điều gì xảy ra khi bạn chạy lệnh?" Tên người dùng của tôi được in ra console.

**Bài học tiếp theo:** Cài đặt Windows Subsystem for Linux (WSL). Tôi sẽ bỏ qua phần này vì tôi không sử dụng Windows. Nếu bạn đang sử dụng Windows, bạn sẽ không thể sử dụng Command Prompt mặc định cho phần còn lại của khóa học. Bạn sẽ sử dụng Linux chạy trên máy Windows của mình với WSL. Nếu bạn đang sử dụng Windows và cần thiết lập WSL, hãy đến bài học này, đó là bài học số 3 trong chương 1. Tất cả các hướng dẫn đều ở đây. Điều này đã được kiểm tra kỹ lưỡng. Chúng tôi đã có hàng ngàn sinh viên cài đặt và sử dụng WSL. Đừng lo, nó sẽ không làm hỏng cài đặt Windows của bạn. Đây không phải là tình huống dual boot nơi bạn phải phân vùng ổ đĩa. Không có gì điên rồ như vậy. Nó thực sự khá đơn giản để thiết lập. Đó là lý do tại sao chúng tôi khuyên dùng n
